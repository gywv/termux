[
  {
    "url": "https://blog.bling.moe/tags/软路由/",
    "title": "软路由 ::\n星野玲的博客",
    "text": "软路由 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/",
    "title": "星野玲的博客",
    "text": "星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 阅读更多 → Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 较旧的文章 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/index.xml",
    "title": "星野玲的博客",
    "text": "星野玲的博客 https://blog.bling.moe/ Recent content on 星野玲的博客 Hugo -- gohugo.io zh-cn Sun, 15 Oct 2023 08:00:00 +0800 使用 fnm 管理 Node.js 版本 https://blog.bling.moe/post/20/ Sun, 15 Oct 2023 08:00:00 +0800 https://blog.bling.moe/post/20/ 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 使用 NetworkManager 配置 Debian 路由器 https://blog.bling.moe/post/19/ Sun, 01 Oct 2023 08:00:00 +0800 https://blog.bling.moe/post/19/ 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 关于 router.push() 会报错这件事 https://blog.bling.moe/post/18/ Sun, 24 Sep 2023 08:00:00 +0800 https://blog.bling.moe/post/18/ 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 友情链接 https://blog.bling.moe/links/ Fri, 17 Feb 2023 00:00:00 +0800 https://blog.bling.moe/links/ 友情链接 Docker 下的 Traefik 上手教程（二） https://blog.bling.moe/post/15/ Sun, 29 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/15/ 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 Docker 下的 Traefik 上手教程 https://blog.bling.moe/post/14/ Sun, 22 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/14/ 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 使用 Kotlin 语言实现一个归并排序算法 https://blog.bling.moe/post/13/ Sun, 15 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/13/ 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 使用 Kotlin 语言实现一个快速排序算法 https://blog.bling.moe/post/12/ Sun, 08 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/12/ 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 `Double` 类型的 `List` 从小到大排序。整个函数代码仅仅只有 11 行。 Windows 包管理器——Scoop 上手教程 https://blog.bling.moe/post/11/ Sun, 01 Jan 2023 23:00:00 +0800 https://blog.bling.moe/post/11/ 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 分享一个 TranslucentTB 的配置 https://blog.bling.moe/post/8/ Sat, 15 Oct 2022 22:00:00 +0800 https://blog.bling.moe/post/8/ 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。"
  },
  {
    "url": "https://blog.bling.moe/about/",
    "title": "关于 ::\n星野玲的博客",
    "text": "关于 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 2021-10-14 你好，咱是星野玲。一个喜欢信息技术、二次元的小透明。 小玲来自中国。 小玲的博客采用的语言是简体中文，面向全球所有的汉语使用者。 小玲的博客的所有文章，如果没有特别注明，均采用 CC BY-NC-SA 4.0 协议 共享哦。 联系方式 # Github: HoshinoRei Matrix： @hoshinorei:matrix.org 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/links/",
    "title": "友情链接 ::\n星野玲的博客",
    "text": "友情链接 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 友情链接 2023-02-17 凛子的导标 Rikki’s Blog 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/index.xml",
    "title": "星野玲的博客",
    "text": "星野玲的博客 https://blog.bling.moe/ Recent content on 星野玲的博客 Hugo -- gohugo.io zh-cn Sun, 15 Oct 2023 08:00:00 +0800 使用 fnm 管理 Node.js 版本 https://blog.bling.moe/post/20/ Sun, 15 Oct 2023 08:00:00 +0800 https://blog.bling.moe/post/20/ 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 使用 NetworkManager 配置 Debian 路由器 https://blog.bling.moe/post/19/ Sun, 01 Oct 2023 08:00:00 +0800 https://blog.bling.moe/post/19/ 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 关于 router.push() 会报错这件事 https://blog.bling.moe/post/18/ Sun, 24 Sep 2023 08:00:00 +0800 https://blog.bling.moe/post/18/ 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 友情链接 https://blog.bling.moe/links/ Fri, 17 Feb 2023 00:00:00 +0800 https://blog.bling.moe/links/ 友情链接 Docker 下的 Traefik 上手教程（二） https://blog.bling.moe/post/15/ Sun, 29 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/15/ 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 Docker 下的 Traefik 上手教程 https://blog.bling.moe/post/14/ Sun, 22 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/14/ 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 使用 Kotlin 语言实现一个归并排序算法 https://blog.bling.moe/post/13/ Sun, 15 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/13/ 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 使用 Kotlin 语言实现一个快速排序算法 https://blog.bling.moe/post/12/ Sun, 08 Jan 2023 00:00:00 +0800 https://blog.bling.moe/post/12/ 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 `Double` 类型的 `List` 从小到大排序。整个函数代码仅仅只有 11 行。 Windows 包管理器——Scoop 上手教程 https://blog.bling.moe/post/11/ Sun, 01 Jan 2023 23:00:00 +0800 https://blog.bling.moe/post/11/ 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 分享一个 TranslucentTB 的配置 https://blog.bling.moe/post/8/ Sat, 15 Oct 2022 22:00:00 +0800 https://blog.bling.moe/post/8/ 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。"
  },
  {
    "url": "https://blog.bling.moe/about/",
    "title": "关于 ::\n星野玲的博客",
    "text": "关于 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 2021-10-14 你好，咱是星野玲。一个喜欢信息技术、二次元的小透明。 小玲来自中国。 小玲的博客采用的语言是简体中文，面向全球所有的汉语使用者。 小玲的博客的所有文章，如果没有特别注明，均采用 CC BY-NC-SA 4.0 协议 共享哦。 联系方式 # Github: HoshinoRei Matrix： @hoshinorei:matrix.org 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/links/",
    "title": "友情链接 ::\n星野玲的博客",
    "text": "友情链接 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 友情链接 2023-02-17 凛子的导标 Rikki’s Blog 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/19/",
    "title": "使用 NetworkManager 配置 Debian 路由器 ::\n星野玲的博客",
    "text": "使用 NetworkManager 配置 Debian 路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《 使用 Debian 作为路由器 》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 这次小玲使用的系统是通过虚拟机安装的 Debian 12，默认没有安装 NetworkManager。 安装 NetworkManager # 首先安装 NetworkManager，如果需要 PPPoE 拨号，还需要安装 ppp 。 sudo apt install -y network-manager ppp nmcli 命令的使用 # 查看网络情况 # 通过 nmcli 命令查看当前网络情况。 可以看到有两个连接外部的网络设备—— ens33 和 ens34 。 ens34 设备已经通过 DHCP 获取了 IP 地址。 ens33 还没有被设置。小玲将 ens34 设备当作 WAN 口， ens33 设备当作 LAN 口。 ens34: connected to Wired connection 1 \"Intel 82545EM\" ethernet (e1000), 00:0C:29:BD:87:34, hw, mtu 1500 ip4 default, ip6 default inet4 192.168.█.9/26 route4 192.168.█.0/26 metric 100 route4 default via 192.168.█.1 metric 100 inet6 240█:████:████:████:████:████:████:████/64 inet6 fe80::90ec:3e41:215c:ac29/64 route6 fe80::/64 metric 1024 route6 240█:████:████:████::/64 metric 100 route6 default via fe80::████:████:████:████ metric 100 lo: connected (externally) to lo \"lo\" loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536 inet4 127.0.0.1/8 inet6 ::1/128 ens33: unmanaged \"Intel 82545EM\" ethernet (e1000), 00:0C:29:BD:87:2A, hw, mtu 1500 DNS configuration: servers: 192.168.█.1 interface: ens34 servers: fe80::████:████:████:████ interface: ens34 Use \"nmcli device show\" to get complete information about known devices and \"nmcli connection show\" to get an overview on active connection profiles. Consult nmcli(1) and nmcli-examples(7) manual pages for complete usage details. 查看网络设备 # 使用 nmcli d 命令查看网络设备。 现在 ens33 设备并没有被 NetworkManager 管理，待会会通过 NetworkManager 创建一个连接，使其被 NetworkManager 管理。 DEVICE  TYPE      STATE                   CONNECTION ens34   ethernet  connected               Wired connection 1 lo      loopback  connected (externally)  lo ens33   ethernet  unmanaged               -- 查看网络连接 # 使用 nmcli c 命令查看网络连接。 只有 Wired connection 1 这个 NetworkManager 自动创建的连接。 NAME                UUID                                  TYPE      DEVICE Wired connection 1  7d5979e9-c222-3fa0-a86e-9c1ea3f330b5  ethernet  ens34 lo                  609bc8f3-b78b-40c6-9836-9f67f0dab964  loopback  lo 创建以太网连接 # 在 ens33 设备上创建一个名为 lan 的以太网连接，这个连接的 IPv4 地址为 192.168.3.1/24 。注意创建时需要 sudo 给权限。 命令里带了双引号的是参数的值，小玲这里是为了让大家看得更明白。 sudo nmcli c add type \"ethernet\" con-name \"lan\" ifname \"ens33\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 如果需要设置静态 IPv6 地址，可以这么添加。 sudo nmcli c add type \"ethernet\" con-name \"lan\" ifname \"ens33\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" ipv6.method \"manual\" ipv6.addresses \"fddd:afcf::/64\" 查看连接详情 # 可以通过 nmcli c show <connection_id|connection_uuid> 查看连接的详情。 比如要查看刚刚添加的 lan 连接，可以通过下面的命令。 nmcli c show \"lan\" 忽略自动下发的 DNS 服务器地址 # 因为 NetworkManager 会控制 /etc/resolv.conf 文件。里面通常是通过 DHCP 获取的 DNS 服务器地址。如果不想被 NetworkManager 控制 /etc/resolv.conf 文件，可以通过下面的命令忽略自动下发的 DNS 服务器地址 sudo nmcli c modify <connection_id|connection_uuid> ipv4.ignore-auto-dns \"yes\" ipv6.ignore-auto-dns \"yes\" 删除一个连接 # 删除一个连接可以用 nmcli c delete <connection_id|connection_uuid> 命令。 如果要把刚刚创建的 lan 连接删除，就可以使用下面的命令。 sudo nmcli c delete \"lan\" 添加 PPPoE 连接 # 如果要通过 ens34 设备使用 PPPoE 拨号，可以创建这么一个连接。 username 和 password 的值，请填写自己的宽带账号和密码。 sudo nmcli c add type \"pppoe\" con-name \"pppoe\" ifname \"ens34\" username \"\" password \"\" 添加成功后，通过下面的命令启动刚刚添加的 pppoe 连接。 sudo nmcli c up pppoe 值得注意的是，通过 nmcli c add 添加的所有连接，都是默认开机自启动的。所以 PPPoE 的连接也是开机自启动的。 注意在 Debian 上使用 PPPoE 拨号的前提是安装 ppp 。如果还没有安装 ppp ，请趁着能联网时安装 ppp 。 sudo apt install -y ppp 获取 IPv6 PD 前缀 # 如果要获取 PD 前缀，并把它添加到 lan 连接上，可以使用下面的命令。 sudo nmcli c modify \"lan\" ipv6.method \"shared\" 通过 NetworkManager 获取 PD 前缀时，几乎没有可以自定义的选项，例如前缀长度，路由器在 lan 连接上的主机地址。不过小玲只能获取一个 /64 前缀，所以不能配置也没有多大负面影响。 如果当前没有 PD 前缀，重新启用 pppoe 连接以获取 PD 前缀。 sudo nmcli c down pppoe && sudo nmcli c up pppoe 自动重新获取 PD 前缀 # 有时候，PPPoE 连接会自己断开重连，这时候如果 PD 前缀没有更新，会导致局域网内的设备无法使用 IPv6。 小玲为了解决这个问题，用了个野路子，思路就是写一个脚本，当 PPPoE 连接断开时，自动禁用并启用 PPPoE 连接以达到重新获取 PD 前缀的目的。 sudo vim /etc/ppp/ipv6-down.d/restart_pppoe #!/usr/bin/bash # CONNECTION_NAME 变量的值为 NetworkManager 里用于 PPPoE 拨号的连接名称 CONNECTION_NAME = pppoe nmcli c down $CONNECTION_NAME && nmcli c up $CONNECTION_NAME 添加一个带 VLAN ID 的连接 # 通过下面的命令来添加一个带 VLAN ID 的连接。 ifname 的值可以自由设置，这里小玲就设置为 ens33.10 。 vlan.parent 的值是这个 VLAN 连接依附的网络设备的名称。 vlan.id 的值可以自由设置，这里小玲就设置为 10 。 sudo nmcli c add type \"vlan\" ifname \"ens33.10\" vlan.parent \"ens33\" vlan.id \"10\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 添加一个网桥并开启 WiFi 热点 # 如果路由器有多个网络设备，可以通过创建一个网桥将它们桥接起来。比如现在有一个 USB 无线网卡，要把它和 LAN 口桥接起来，LAN 提供有线连接，USB 无线网卡开启热点后提供无线连接。那么可以这么设置。 注意，如果 LAN 口上已经有连接了，需要先把 LAN 口的连接删除。 先用 nmcli d 查看 USB 无线网卡的设备名称。 DEVICE                   TYPE      STATE                   CONNECTION ens34                    ethernet  connected               Wired connection 1 lo                       loopback  connected (externally)  lo ens33                    ethernet  unmanaged               -- wlx908d78eb1c7b          wifi      disconnected            -- p2p-dev-wlx908d78eb1c7b  wifi-p2p  disconnected            -- USB 无线网卡的设备名称为 wlx908d78eb1c7b 。 通过下面的命令创建一个名为 bridge 的网桥， ifname 的值可以自由设置，这里小玲就设置为 br0 。 sudo nmcli c add type \"bridge\" con-name \"bridge\" ifname \"br0\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 将 ens33 设备加入刚刚创建的网桥。 sudo nmcli c add type \"bridge-slave\" ifname \"ens33\" master \"br0\" 通过下面的命令创建一个无线的连接。 wifi.band 是 WiFi 的频段，值为 a 或 bg 。无论哪个都是特别慢的， nmcli 并不支持 WiFi 5 甚至 WiFi 6。 wifi.ssid 的值请填写自己想设置的 SSID。 802-11-wireless-security.key-mgmt \"wpa-psk\" 和 802-11-wireless-security.proto \"rsn\" 这两个参数将 WiFi 加密方式设置为 WPA2。 802-11-wireless-security.psk 的值请填写自己想设置的密码。 sudo nmcli c add type \"wifi\" ifname \"wlx908d78eb1c7b\" master \"br0\" wifi.band \"a\" wifi.mode \"ap\" wifi.ssid \"\" 802-11-wireless-security.key-mgmt \"wpa-psk\" 802-11-wireless-security.proto \"rsn\" 802-11-wireless-security.psk \"\" 小玲并不建议大家通过 NetworkManager 开启 WiFi 热点，因为速度实在是太慢了，如果有这方面的需求，小玲的建议是买一个无线路由器通过网线连接 LAN 口后当作 AP。 如果要使用 Tproxy 透明代理，小玲也不建议设置网桥。因为 nftables 对网桥的数据的处理有些问题。小玲在这里只是介绍这个方法而已，并不是建议大家使用网桥。 连接 WiFi # 通过 nmcli d wifi list ifname \"\" 命令查看无线网卡， ifname 的值请填写自己的无线网卡设备名。如果只有一张无线网卡，那么这个命令可以省略为 nmcli d wifi 。 通过 nmcli d wifi connect \"\" password \"\" ifname \"\" 命令连接 WiFi， connect 的值请填写要连接的 WiFi 的 SSID， password 的值请填写 WiFi 的密码， ifname 的值请填写自己的无线网卡设备名。如果只有一张无线网卡，那么 ifname 及其后面的内容可以省略。 结尾 # 这篇文章更多的是一篇补充性而不是教程性的文章，所以没看过小玲之前的文章的话有可能看不懂。如果看不懂请看《 使用 Debian 作为路由器 》和《 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 》。 阅读其它文章 ← 使用 fnm 管理 Node.js 版本 关于 router.push() 会报错这件事 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/debian/",
    "title": "Debian ::\n星野玲的博客",
    "text": "Debian ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/",
    "title": "路由器 ::\n星野玲的博客",
    "text": "路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/",
    "title": "软路由 ::\n星野玲的博客",
    "text": "软路由 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/19/",
    "title": "使用 NetworkManager 配置 Debian 路由器 ::\n星野玲的博客",
    "text": "使用 NetworkManager 配置 Debian 路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《 使用 Debian 作为路由器 》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 这次小玲使用的系统是通过虚拟机安装的 Debian 12，默认没有安装 NetworkManager。 安装 NetworkManager # 首先安装 NetworkManager，如果需要 PPPoE 拨号，还需要安装 ppp 。 sudo apt install -y network-manager ppp nmcli 命令的使用 # 查看网络情况 # 通过 nmcli 命令查看当前网络情况。 可以看到有两个连接外部的网络设备—— ens33 和 ens34 。 ens34 设备已经通过 DHCP 获取了 IP 地址。 ens33 还没有被设置。小玲将 ens34 设备当作 WAN 口， ens33 设备当作 LAN 口。 ens34: connected to Wired connection 1 \"Intel 82545EM\" ethernet (e1000), 00:0C:29:BD:87:34, hw, mtu 1500 ip4 default, ip6 default inet4 192.168.█.9/26 route4 192.168.█.0/26 metric 100 route4 default via 192.168.█.1 metric 100 inet6 240█:████:████:████:████:████:████:████/64 inet6 fe80::90ec:3e41:215c:ac29/64 route6 fe80::/64 metric 1024 route6 240█:████:████:████::/64 metric 100 route6 default via fe80::████:████:████:████ metric 100 lo: connected (externally) to lo \"lo\" loopback (unknown), 00:00:00:00:00:00, sw, mtu 65536 inet4 127.0.0.1/8 inet6 ::1/128 ens33: unmanaged \"Intel 82545EM\" ethernet (e1000), 00:0C:29:BD:87:2A, hw, mtu 1500 DNS configuration: servers: 192.168.█.1 interface: ens34 servers: fe80::████:████:████:████ interface: ens34 Use \"nmcli device show\" to get complete information about known devices and \"nmcli connection show\" to get an overview on active connection profiles. Consult nmcli(1) and nmcli-examples(7) manual pages for complete usage details. 查看网络设备 # 使用 nmcli d 命令查看网络设备。 现在 ens33 设备并没有被 NetworkManager 管理，待会会通过 NetworkManager 创建一个连接，使其被 NetworkManager 管理。 DEVICE  TYPE      STATE                   CONNECTION ens34   ethernet  connected               Wired connection 1 lo      loopback  connected (externally)  lo ens33   ethernet  unmanaged               -- 查看网络连接 # 使用 nmcli c 命令查看网络连接。 只有 Wired connection 1 这个 NetworkManager 自动创建的连接。 NAME                UUID                                  TYPE      DEVICE Wired connection 1  7d5979e9-c222-3fa0-a86e-9c1ea3f330b5  ethernet  ens34 lo                  609bc8f3-b78b-40c6-9836-9f67f0dab964  loopback  lo 创建以太网连接 # 在 ens33 设备上创建一个名为 lan 的以太网连接，这个连接的 IPv4 地址为 192.168.3.1/24 。注意创建时需要 sudo 给权限。 命令里带了双引号的是参数的值，小玲这里是为了让大家看得更明白。 sudo nmcli c add type \"ethernet\" con-name \"lan\" ifname \"ens33\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 如果需要设置静态 IPv6 地址，可以这么添加。 sudo nmcli c add type \"ethernet\" con-name \"lan\" ifname \"ens33\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" ipv6.method \"manual\" ipv6.addresses \"fddd:afcf::/64\" 查看连接详情 # 可以通过 nmcli c show <connection_id|connection_uuid> 查看连接的详情。 比如要查看刚刚添加的 lan 连接，可以通过下面的命令。 nmcli c show \"lan\" 忽略自动下发的 DNS 服务器地址 # 因为 NetworkManager 会控制 /etc/resolv.conf 文件。里面通常是通过 DHCP 获取的 DNS 服务器地址。如果不想被 NetworkManager 控制 /etc/resolv.conf 文件，可以通过下面的命令忽略自动下发的 DNS 服务器地址 sudo nmcli c modify <connection_id|connection_uuid> ipv4.ignore-auto-dns \"yes\" ipv6.ignore-auto-dns \"yes\" 删除一个连接 # 删除一个连接可以用 nmcli c delete <connection_id|connection_uuid> 命令。 如果要把刚刚创建的 lan 连接删除，就可以使用下面的命令。 sudo nmcli c delete \"lan\" 添加 PPPoE 连接 # 如果要通过 ens34 设备使用 PPPoE 拨号，可以创建这么一个连接。 username 和 password 的值，请填写自己的宽带账号和密码。 sudo nmcli c add type \"pppoe\" con-name \"pppoe\" ifname \"ens34\" username \"\" password \"\" 添加成功后，通过下面的命令启动刚刚添加的 pppoe 连接。 sudo nmcli c up pppoe 值得注意的是，通过 nmcli c add 添加的所有连接，都是默认开机自启动的。所以 PPPoE 的连接也是开机自启动的。 注意在 Debian 上使用 PPPoE 拨号的前提是安装 ppp 。如果还没有安装 ppp ，请趁着能联网时安装 ppp 。 sudo apt install -y ppp 获取 IPv6 PD 前缀 # 如果要获取 PD 前缀，并把它添加到 lan 连接上，可以使用下面的命令。 sudo nmcli c modify \"lan\" ipv6.method \"shared\" 通过 NetworkManager 获取 PD 前缀时，几乎没有可以自定义的选项，例如前缀长度，路由器在 lan 连接上的主机地址。不过小玲只能获取一个 /64 前缀，所以不能配置也没有多大负面影响。 如果当前没有 PD 前缀，重新启用 pppoe 连接以获取 PD 前缀。 sudo nmcli c down pppoe && sudo nmcli c up pppoe 自动重新获取 PD 前缀 # 有时候，PPPoE 连接会自己断开重连，这时候如果 PD 前缀没有更新，会导致局域网内的设备无法使用 IPv6。 小玲为了解决这个问题，用了个野路子，思路就是写一个脚本，当 PPPoE 连接断开时，自动禁用并启用 PPPoE 连接以达到重新获取 PD 前缀的目的。 sudo vim /etc/ppp/ipv6-down.d/restart_pppoe #!/usr/bin/bash # CONNECTION_NAME 变量的值为 NetworkManager 里用于 PPPoE 拨号的连接名称 CONNECTION_NAME = pppoe nmcli c down $CONNECTION_NAME && nmcli c up $CONNECTION_NAME 添加一个带 VLAN ID 的连接 # 通过下面的命令来添加一个带 VLAN ID 的连接。 ifname 的值可以自由设置，这里小玲就设置为 ens33.10 。 vlan.parent 的值是这个 VLAN 连接依附的网络设备的名称。 vlan.id 的值可以自由设置，这里小玲就设置为 10 。 sudo nmcli c add type \"vlan\" ifname \"ens33.10\" vlan.parent \"ens33\" vlan.id \"10\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 添加一个网桥并开启 WiFi 热点 # 如果路由器有多个网络设备，可以通过创建一个网桥将它们桥接起来。比如现在有一个 USB 无线网卡，要把它和 LAN 口桥接起来，LAN 提供有线连接，USB 无线网卡开启热点后提供无线连接。那么可以这么设置。 注意，如果 LAN 口上已经有连接了，需要先把 LAN 口的连接删除。 先用 nmcli d 查看 USB 无线网卡的设备名称。 DEVICE                   TYPE      STATE                   CONNECTION ens34                    ethernet  connected               Wired connection 1 lo                       loopback  connected (externally)  lo ens33                    ethernet  unmanaged               -- wlx908d78eb1c7b          wifi      disconnected            -- p2p-dev-wlx908d78eb1c7b  wifi-p2p  disconnected            -- USB 无线网卡的设备名称为 wlx908d78eb1c7b 。 通过下面的命令创建一个名为 bridge 的网桥， ifname 的值可以自由设置，这里小玲就设置为 br0 。 sudo nmcli c add type \"bridge\" con-name \"bridge\" ifname \"br0\" ipv4.method \"manual\" ipv4.addresses \"192.168.3.1/24\" 将 ens33 设备加入刚刚创建的网桥。 sudo nmcli c add type \"bridge-slave\" ifname \"ens33\" master \"br0\" 通过下面的命令创建一个无线的连接。 wifi.band 是 WiFi 的频段，值为 a 或 bg 。无论哪个都是特别慢的， nmcli 并不支持 WiFi 5 甚至 WiFi 6。 wifi.ssid 的值请填写自己想设置的 SSID。 802-11-wireless-security.key-mgmt \"wpa-psk\" 和 802-11-wireless-security.proto \"rsn\" 这两个参数将 WiFi 加密方式设置为 WPA2。 802-11-wireless-security.psk 的值请填写自己想设置的密码。 sudo nmcli c add type \"wifi\" ifname \"wlx908d78eb1c7b\" master \"br0\" wifi.band \"a\" wifi.mode \"ap\" wifi.ssid \"\" 802-11-wireless-security.key-mgmt \"wpa-psk\" 802-11-wireless-security.proto \"rsn\" 802-11-wireless-security.psk \"\" 小玲并不建议大家通过 NetworkManager 开启 WiFi 热点，因为速度实在是太慢了，如果有这方面的需求，小玲的建议是买一个无线路由器通过网线连接 LAN 口后当作 AP。 如果要使用 Tproxy 透明代理，小玲也不建议设置网桥。因为 nftables 对网桥的数据的处理有些问题。小玲在这里只是介绍这个方法而已，并不是建议大家使用网桥。 连接 WiFi # 通过 nmcli d wifi list ifname \"\" 命令查看无线网卡， ifname 的值请填写自己的无线网卡设备名。如果只有一张无线网卡，那么这个命令可以省略为 nmcli d wifi 。 通过 nmcli d wifi connect \"\" password \"\" ifname \"\" 命令连接 WiFi， connect 的值请填写要连接的 WiFi 的 SSID， password 的值请填写 WiFi 的密码， ifname 的值请填写自己的无线网卡设备名。如果只有一张无线网卡，那么 ifname 及其后面的内容可以省略。 结尾 # 这篇文章更多的是一篇补充性而不是教程性的文章，所以没看过小玲之前的文章的话有可能看不懂。如果看不懂请看《 使用 Debian 作为路由器 》和《 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 》。 阅读其它文章 ← 使用 fnm 管理 Node.js 版本 关于 router.push() 会报错这件事 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/debian/",
    "title": "Debian ::\n星野玲的博客",
    "text": "Debian ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E5%8D%8E%E7%A1%95ax86u/",
    "title": "华硕AX86U ::\n星野玲的博客",
    "text": "华硕AX86U ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/",
    "title": "路由器 ::\n星野玲的博客",
    "text": "路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/",
    "title": "软路由 ::\n星野玲的博客",
    "text": "软路由 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/7/",
    "title": "Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 ::\n星野玲的博客",
    "text": "Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 这样的好处是比如家里来了客人的话，可以让客人连接上客人专用的 WiFi。因为客人用的 WiFi 与小玲专用的 WiFi 之间是 VLAN 隔离的，客人就无法访问到小玲的局域网里的 NAS 之类的设备。或者小玲有一些智能家居设备，把这些智能家居设备放进一个局域网里，然后与小玲专用的局域网之间隔离，可以防止一些潜在的隐私窥探问题。 以前小玲用过一个能刷集客 AP 固件的路由器，集客 AP 固件可以在一个路由器里创建多个 SSID，并且还能设置 VLAN ID。不过现在没见过能刷集客 AP 固件的 WiFi 6 路由器了。好在小玲买的 AX86U 能通过一个野路子实现小玲的需求。小玲很庆幸买对了路由器，要是买了 TP-Link 估计就要跟这个功能说拜拜了。 设备介绍 # 首先，先介绍一下要使用的设备。R4S 是小玲目前在用的软路由，刷了 Armbian 系统，它的设置请看 这篇文章 。 AX86U 刷了梅林固件，小玲不清楚原版固件能不能实现这个功能，如果不能请像小玲一样刷梅林固件。 网段规划 # 然后规划一下网段。小玲原本在 R4S 里给整个局域网设置的 IPv4 网段为 192.168.3.0/24 。小玲决定把它拆分成 4 个子网。它们分别如下。 网段 第一个可用地址 最后一个可用地址 用途 192.168.3.0/26 192.168.3.1 192.168.3.62 小玲专用的局域网 192.168.3.64/26 192.168.3.65 192.168.3.126 家人专用的局域网 192.168.3.128/26 192.168.3.129 192.168.3.190 访客专用的局域网 192.168.3.192/26 192.168.3.193 192.168.3.254 智能家居专用的局域网 上面每个子网的可用 IP 数都是 62，这个数量对小玲来说够用了。 小玲用的宽带只能获取到一个 IPv6 的 /64 前缀，小玲打算将这个前缀用于小玲专用的局域网。另外 3 个局域网就无法使用公网 IPv6 地址了。虽然没有公网 IPv6 地址，但是小玲还可以设置 ULA 1 ，然后通过 NAT，让另外 3 个局域网获得访问 IPv6 地址的能力。使用这个 网站 可以生成一个 ULA 的网段，小玲生成的网段是 fddd:afcf::/48 ，小玲决定拿出这里面的前 3 个 /64 网段来分别给另外 3 个局域网使用。为什么要用 /64 这么大的网段呢？因为比 /64 更小的网段就无法通过 SLAAC 分配 IP 地址，也就是说安卓设备无法被分配到这个网段的 IP 地址了。 2 ULA 网段 用途 不需要 小玲专用的局域网 fddd:afcf::/64 家人专用的局域网 fddd:afcf:0:1::/64 访客专用的局域网 fddd:afcf:0:2::/64 智能家居专用的局域网 每个网段在 R4S 里的地址都被小玲指定为了第一个可用地址，也就是说，R4S 现在拥有 4 个局域网的 IPv4 地址，3 个局域网的 IPv6 地址，它们分别如下。 192.168.3.1 192.168.3.65 192.168.3.129 192.168.3.193 fddd:afcf:: fddd:afcf:0:1:: fddd:afcf:0:2:: VLAN ID 规划 # 网段规划完了，现在要规划 VLAN ID，VLAN ID 不仅在 R4S 里用到 AX86U 里也要用到。 VLAN ID 用途 无 小玲专用的局域网 10 家人专用的局域网 20 访客专用的局域网 30 智能家居专用的局域网 网桥规划 # 默认情况下，AX86U 里只有一个网桥，名字叫 br0 。 br0 网桥的成员默认就是所有的接口。小玲因为有 4 个局域网，所以需要 4 个网桥。网桥的名称可以自定义，这里小玲就用 br1 、 br2 等作为网桥名吧。 网桥 用途 br0 小玲专用的局域网 br1 家人专用的局域网 br2 访客专用的局域网 br3 智能家居专用的局域网 设置网段与 VLAN ID # 网段和 VLAN ID 规划好后，现在就需要在 R4S 里设置网段和 VLAN ID 了。 在 R4S 里编辑 /etc/network/interfaces 。 sudo vim /etc/network/interfaces R4S 的 LAN 口的接口名称是 enp1s0 ，在 enp1s0 后面加上一个 .<数字> 表示这个接口是一个以这个数字为 VLAN ID 的接口。例如 enp1s0.10 这个接口的 VLAN ID 是 10 ， enp1s0.20 这个接口的 VLAN ID 是 20 。 auto enp1s0 allow-hotplug enp1s0 iface enp1s0 inet static address 192.168.3.1/26 auto enp1s0.10 allow-hotplug enp1s0.10 iface enp1s0.10 inet static address 192.168.3.65/26 iface enp1s0.10 inet6 static address fddd:afcf::/64 auto enp1s0.20 allow-hotplug enp1s0.20 iface enp1s0.20 inet static address 192.168.3.129/26 iface enp1s0.20 inet6 static address fddd:afcf:0:1::/64 auto enp1s0.30 allow-hotplug enp1s0.30 iface enp1s0.30 inet static address 192.168.3.193/26 iface enp1s0.30 inet6 static address fddd:afcf:0:2::/64 设置 Dnsmasq # 还需要设置 Dnsmasq 以给每个网段的设备自动分配 IP 地址。小玲使用的 Dnsmasq 是通过 这篇文章 里安装的 Dnsmasq。 在 R4S 里编辑 dnsmasq.conf 。 vim ~/config/dnsmasq/dnsmasq.conf 下面的内容已省略无关配置。 # 监听这 4 个接口 interface=enp1s0 interface=enp1s0.10 interface=enp1s0.20 interface=enp1s0.30 dhcp-range=interface:enp1s0,192.168.3.2,192.168.3.62,1h dhcp-range=interface:enp1s0,::,constructor:enp1s0,ra-stateless,1h dhcp-option=interface:enp1s0,option:router,192.168.3.1 dhcp-option=interface:enp1s0,option:dns-server,192.168.3.1 # 这里的 fe80::362f:579d:8c86:105b 请换成你的本地链路地址 dhcp-option=interface:enp1s0,option6:dns-server,[fe80::362f:579d:8c86:105b] dhcp-range=interface:enp1s0.10,192.168.3.66,192.168.3.126,1h dhcp-range=interface:enp1s0.10,::,constructor:enp1s0.10,ra-stateless,1h dhcp-option=interface:enp1s0.10,option:router,192.168.3.65 dhcp-option=interface:enp1s0.10,option:dns-server,192.168.3.65 dhcp-option=interface:enp1s0.10,option6:dns-server,[fddd:afcf::] dhcp-range=interface:enp1s0.20,192.168.3.130,192.168.3.190,1h dhcp-range=interface:enp1s0.20,::,constructor:enp1s0.20,ra-stateless,1h dhcp-option=interface:enp1s0.20,option:router,192.168.3.129 dhcp-option=interface:enp1s0.20,option:dns-server,192.168.3.129 dhcp-option=interface:enp1s0.20,option6:dns-server,[fddd:afcf:0:1::] dhcp-range=interface:enp1s0.30,192.168.3.194,192.168.3.254,1h dhcp-range=interface:enp1s0.30,::,constructor:enp1s0.30,ra-stateless,1h dhcp-option=interface:enp1s0.30,option:router,192.168.3.193 dhcp-option=interface:enp1s0.30,option:dns-server,192.168.3.193 dhcp-option=interface:enp1s0.30,option6:dns-server,[fddd:afcf:0:2::] 设置 WiFi # 设置完 R4S，接下来就要设置 AX86U 了。先在 AX86U 里设置 WiFi。小玲专用的 WiFi 就在 无线网络 里设置，家人专用的 WiFi、访客专用的 WiFi、智能家居专用的 WiFi 在 访客网络 里设置。同时请把 AX86U 的操作模式设为 无线接入点（AP）模式 。 在这里有一个问题需要弄明白，那就是在 AX86U 的系统里，网络接口是以 eth0 、 eth1 这样的字符串表示的。咱们需要知道哪个网口和哪个 WiFi 对应哪个接口。好在小玲找到一份对应关系。 3 不过这个对应关系不包含访客网络的接口。小玲又自己测试了一下，整理出了以下的对应关系。 物理网口或 WLAN 接口 系统内的接口名称 WAN eth0 LAN4 eth1 LAN3 eth2 LAN2 eth3 LAN1 eth4 2.5G LAN eth5 2.4GHz WLAN eth6 5GHz WLAN eth7 2.4GHz WLAN 访客网络1 wl0.1 2.4GHz WLAN 访客网络2 wl0.2 2.4GHz WLAN 访客网络3 wl0.3 5GHz WLAN 访客网络1 wl1.1 5GHz WLAN 访客网络2 wl1.2 5GHz WLAN 访客网络3 wl1.3 访客网络在下图中有两行三列，从左到右分别以 1、2、3 来表示。例如 2.4GHz 的第一列对应的系统内接口名称是 wl0.1 ，5GHz 的第二列对应的系统内接口名称是 wl1.2 。 设置 WiFi 的 VLAN # 清楚了对应关系后，咱们就可以通过 SSH 进入 AX86U 的命令行里设置 VLAN 了。首先请确保 AX86U 的 SSH 功能是开启的，在 系统管理 → 系统设置 → 服务 → 启用 SSH 里可以设置。 下面的方法小玲参考了 Github Gist 上的 一段代码 ，在此感谢这段代码的作者。 首先增加带 VLAN ID 的接口。这里使用 eth0 是因为小玲把连接着 R4S 的网线接到了 AX86U 的 WAN 口上了，而 WAN 口对应的系统内接口名称是 eth0 。 ip link add link eth0 name eth0.10 type vlan id 10 ip link add link eth0 name eth0.20 type vlan id 20 ip link add link eth0 name eth0.30 type vlan id 30 通过 ip link 可以看到咱们刚添加的接口。 29: eth0.10@eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 30: eth0.20@eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 31: eth0.30@eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 可以看到咱们刚添加的接口都是 DOWN 的。因为光添加还不行，咱们还需要启用这些接口，把它变成 UP 的。 ip link set eth0.10 up ip link set eth0.20 up ip link set eth0.30 up 通过 ip link 可以看到咱们刚添加的接口已经启用了。 29: eth0.10@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 30: eth0.20@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 31: eth0.30@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP mode DEFAULT group default link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 通过 brctl show 查看所有的网桥。 admin@RT-AX86U-████:/tmp/home/root# brctl show bridge name     bridge id               STP enabled     interfaces br0             8000.████████████       no              eth0 eth1 eth2 eth3 eth4 eth5 eth6 eth7 wl0.1 wl0.2 wl0.3 wl1.1 wl1.2 可以看到默认只有一个网桥 br0 ，还需要添加三个网桥。 brctl addbr br1 brctl addbr br2 brctl addbr br3 添加网桥后也要像上面启用接口一样启用网桥。 ip link set br1 up ip link set br2 up ip link set br3 up 再用 brctl show 查看，就可以看到已经添加了三个网桥。 admin@RT-AX86U-████:/tmp/home/root# brctl show bridge name     bridge id               STP enabled     interfaces br0             8000.████████████       no              eth0 eth1 eth2 eth3 eth4 eth5 eth6 eth7 wl0.1 wl0.2 wl0.3 wl1.1 wl1.2 br1             8000.000000000000       no br2             8000.000000000000       no br3             8000.000000000000       no 现在需要从 br0 网桥中删除不属于它的接口，需要用 brctl delif 这个命令，它的语法如下。 brctl delif <bridge> <device...> brctl delif br0 wl0.1 wl1.1 wl0.2 wl0.3 wl1.2 admin@RT-AX86U-████:/tmp/home/root# brctl show bridge name     bridge id               STP enabled     interfaces br0             8000.████████████       no              eth0 eth1 eth2 eth3 eth4 eth5 eth6 eth7 br1             8000.000000000000       no br2             8000.000000000000       no br3             8000.000000000000       no 小玲把 2.4GHz WLAN 访客网络1 和 5GHz WLAN 访客网络1 当作家人专用的 WiFi； 2.4GHz WLAN 访客网络2 和 5GHz WLAN 访客网络2 当作访客专用的 WiFi， 2.4GHz WLAN 访客网络3 当作智能家居专用的 WiFi。所以小玲需要把 eth0.10 、 wl0.1 、 wl1.1 这三个接口添加进 br1 网桥； eth0.20 、 wl0.2 、 wl1.2 添加进 br2 网桥； eth0.30 、 wl0.3 添加进 br3 网桥。 把接口添加进网桥需要用 brctl addif 这个命令，它的语法如下。 brctl addif <bridge> <device...> brctl addif br1 eth0.10 wl0.1 wl1.1 brctl addif br2 eth0.20 wl0.2 wl1.2 brctl addif br3 eth0.30 wl0.3 admin@RT-AX86U-████:/tmp/home/root# brctl show bridge name     bridge id               STP enabled     interfaces br0             8000.████████████       no              eth0 eth1 eth2 eth3 eth4 eth5 eth6 eth7 br1             8000.████████████       no              eth0.10 wl0.1 wl1.1 br2             8000.████████████       no              eth0.20 wl0.2 wl1.2 br3             8000.████████████       no              eth0.30 wl0.3 这时候已经成功了，小玲试着连接上家人专用的 WiFi，可以看到被分配的 IPv4 地址正好在 192.168.3.64/26 内，连接上访客专用的 WiFi，IPv4 地址正好在 192.168.3.128/26 之内，连接上智能家居专用的 WiFi，IPv4 地址正好在 192.168.3.192/26 之内。 自动化 # 现在已经实现了想要的功能，接下来就要让 AX86U 自动帮咱们完成上面这一整套步骤。小玲为此写了一个脚本。要想保存这个脚本，请先打开 AX86U 设置中的 系统管理 → 系统设置 → Persistent JFFS2 partition → Enable JFFS custom scripts and configs 。 AX86U 的系统里没有 vim，所以咱们只能用 vi。 vi /jffs/scripts/vlan 写入以下内容 #!/bin/sh # 这个变量的值是连接软路由的那个网口的系统内的接口名称，小玲用的是 WAN 口，所以是 eth0。 lan_ifname = eth0 # 这个函数的作用是增加并启用带有 VLAN ID 的接口，如果要添加的接口已存在就什么也不做。 # 形参1：接口名称 # 形参2：VLAN ID # 例如 \"add_vlan_if eth0 10\" 会在 \"eth0.10\" 这个 VLAN ID 为 10 的接口不存在时添加这个接口。 function add_vlan_if () { ip link | grep $1.$2 > /dev/null if [ $? == 1 ] ; then ip link add link $1 name \" ${ 1 } . ${ 2 } \" type vlan id $2 fi ip link show $1.$2 | grep DOWN > /dev/null if [ $? == 0 ] ; then ip link set \" ${ 1 } . ${ 2 } \" up fi } # 这个函数的作用是增加并启用网桥，如果要添加的网桥已存在就什么也不做。 # 形参1：网桥名称 # 例如 \"add_br br1\" 会在 \"br1\" 这个网桥不存在时添加这个网桥。 function add_br () { brctl show | grep $1 > /dev/null if [ $? == 1 ] ; then brctl addbr $1 > /dev/null fi ip link show $1 | grep DOWN > /dev/null if [ $? == 0 ] ; then ip link set $1 up > /dev/null fi } # 这个函数的作用是把一个接口添加到网桥，如果要添加的接口已经在这个网桥里了就什么也不做。 # 形参1：网桥名称 # 形参2：接口名称 # 例如 \"add_if_to_br br1 eth0.10\" 会在 \"eth0.10\" 这个接口不在 \"br1\" 网桥里时，将 \"eth0.10\" 接口添加进 \"br1\" 网桥。 function add_if_to_br () { brctl show $1 | grep $2 > /dev/null if [ $? == 1 ] ; then brctl addif $1 $2 > /dev/null fi } # 这个函数的作用是把一个接口从一个网桥里删除，如果要删除的接口不在这个网桥里就什么也不做。 # 形参1：网桥名称 # 形参2：接口名称 # 例如 \"delete_if_from_br br1 eth0.10\" 会在 \"eth0.10\" 这个接口在 \"br1\" 网桥里时，将 \"eth0.10\" 接口从 \"br1\" 网桥里删除。 function delete_if_from_br () { brctl show $1 | grep $2 > /dev/null if [ $? == 0 ] ; then brctl delif br0 $2 > /dev/null fi } # 下面的语句都是调用上面的函数了。 # 添加并启用 \"eth0.10\"、\"eth0.20\" \"eth0.30\" 三个接口。 add_vlan_if $lan_ifname 10 add_vlan_if $lan_ifname 20 add_vlan_if $lan_ifname 30 # 添加并启用 \"br1\"、\"br2\"、\"br3\" 三个网桥。 add_br br1 add_br br2 add_br br3 # 把用到的访客网络的接口从 `br0` 网桥里删除。 delete_if_from_br br0 wl0.1 delete_if_from_br br0 wl0.2 delete_if_from_br br0 wl0.3 delete_if_from_br br0 wl1.1 delete_if_from_br br0 wl1.2 # 添加接口到相应的网桥里。 add_if_to_br br1 $lan_ifname.10 add_if_to_br br1 wl0.1 add_if_to_br br1 wl1.1 add_if_to_br br2 $lan_ifname.20 add_if_to_br br2 wl0.2 add_if_to_br br2 wl1.2 add_if_to_br br3 $lan_ifname.30 add_if_to_br br3 wl0.3 可惜 AX86U 的 Shell 是那种超简陋的 Shell，连数组都不能定义，不然小玲可以写数组遍历的。 给脚本添加执行权限。 chmod +x /jffs/scripts/vlan 为了让 AX86U 每次开机时都执行一遍这个脚本，咱们需要在 /jffs/scripts/services-start 这个文件里添加这么一行。 /jffs/scripts/vlan 这样 AX86U 每次开机时就会自动配置好 VLAN、网桥什么的。不过有时候咱们更改了 AX86U 的一些设置都会导致网桥和接口复原，这时候只能进 SSH 手动执行一下脚本来恢复配置，或者用一个笨办法，那就是用定时任务每分钟执行一遍脚本来自动恢复设置。这个问题小玲暂时找不到很好的解决方法，如果你知道解决方法，不妨在评论区告诉小玲。 防火墙配置 # 现在小玲连接上访客专用的 WiFi（ 192.168.3.128/26 网段），并试图去 ping 处于 192.168.3.0/26 的 NAS 时，发现是可以 ping 通的，这样是不行的。小玲的想法是小玲专用的局域网里的设备能主动访问其它三个局域网里的设备，其他三个局域网的设备只能主动访问它自己网内的设备。用表格表示如下。 访问方\\被访问方 小玲专用的局域网 家人专用的局域网 访客专用的局域网 智能家居专用的局域网 小玲专用的局域网 ✓ ✓ ✓ ✓ 家人专用的局域网 ✗ ✓ ✗ ✗ 访客专用的局域网 ✗ ✗ ✓ ✗ 智能家居专用的局域网 ✗ ✗ ✗ ✓ 这个需求可以在 R4S 上通过 nftables 实现。在 filter 表里的 forward 链里添加这么一句就能禁止其它三个局域网里的设备主动访问小玲专用的局域网里的设备。同时小玲专用的局域网里的设备能正常访问其他三个局域网里的设备。 sudo vim /etc/nftables.conf # 已省略无关内容 table inet filter { chain forward { type filter hook forward priority 0; iifname enp1s0.10 oifname { enp1s0, enp1s0.20, enp1s0.30 } ct state { new, invalid } drop iifname enp1s0.20 oifname { enp1s0, enp1s0.10, enp1s0.30 } ct state { new, invalid } drop iifname enp1s0.30 oifname { enp1s0, enp1s0.10, enp1s0.20 } ct state { new, invalid } drop } } IPv6 访问问题 # 小玲用的宽带只能获取到一个 /64 的前缀，这个前缀已经用于小玲专用的局域网，让它里面的设备都有公网 IPv6 地址了。 由于没有更多的前缀，所以其它三个局域网里的设备无法获得公网 IPv6 地址。虽然如此，小玲还是至少要让其它三个局域网里的设备能正常访问 IPv6 地址，这时候就需要在 R4S 里用 nftables 做 IPv6 的 NAT。 sudo vim /etc/nftables.conf # 已省略无关内容 table ip6 ipv6-nat { chain postrouting { type nat hook postrouting priority srcnat; policy accept; iifname { enp1s0.10, enp1s0.20, enp1s0.30 } oifname ppp0 masquerade } } ppp0 是小玲的 R4S PPPoE 拨号用的接口名称，请根据实际情况换成你的接口名称。 结尾 # 好了，现在终于实现小玲的需求了。其实这个需求不用 AX86U 也能实现，一般能刷梅林的路由器应该都能像这篇文章一样操作。小玲并不是什么精通计算机的大佬，可能讲的不是很专业和严谨，如果有错误欢迎在评论区指出，在此感谢。 参考： 为你的 IPv6 局域网配置 ULA 吧 ↩︎ 参考： 现在运营商分配 IPV6 地址前缀是/64 吗？ 。 ↩︎ 来源： VLANs, Trunk interface, tagged and untagged traffic RT-AX86U and RT-AX88U 。 ↩︎ 阅读其它文章 ← 分享一个 TranslucentTB 的配置 华硕AX86U 鬼灭之刃版伪开箱 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/3/",
    "title": "使用 Debian 作为路由器 ::\n星野玲的博客",
    "text": "使用 Debian 作为路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。小玲使用一台 Nanopi R4S 作为演示用的设备，刷入的系统为 Armbian 21.08.1，Debian 版本为 11。你也可以用 X86 的设备，设置过程基本上没有区别。 将 Armbian 系统刷入 TF 卡后，咱们将卡插入 R4S 的 TF 卡槽里，使用一条网线接在原本的路由器的 LAN 口上，然后给 R4S 通电。 找到 R4S 通过 DHCP 获取的 IP 地址。用默认用户名 root ，默认密码 1234 登录 SSH。在完成 Armbian 系统的初始设置后，咱们现在得到了一个干净的 Armbian 系统。下面的步骤都是用在 Armbian 系统的初始设置里创建的非 root 用户操作的。小玲不建议大家直接用 root 用户操作。 设置密钥 # 安装完后第一步是要确保路由器安全，因为当设置好后路由器是要暴露在公网上的。有人会扫描 IPv4 的 IP 段，然后再扫描能连通的 IP 地址的端口。如果发现是 SSH 端口，还会爆破。所以咱们要使用密钥文件登录，而且要把密码登录关闭。 创建存放密钥的文件夹，默认路径是家目录下的 .ssh 文件夹。 mkdir ~/.ssh 写入密钥。这里密钥请替换成你自己的。 echo 'ssh-rsa <private_key>' >> ~/.ssh/authorized_keys 编辑 sshd 配置文件。 sudo vim /etc/ssh/sshd_config 将 PermitRootLogin 设为 no 以关闭 root 账号登录；将 PubkeyAuthentication 设为 yes 以开启密钥登录； AuthorizedKeyFile 为密钥路径；将 PasswordAuthentication 设为 no 以关闭密码登录。 PermitRootLogin no PubkeyAuthentication yes AuthorizedKeyFile .ssh/authorized_keys .ssh/authorized_keys2 PasswordAuthentication no 保存后，重启 SSH 服务。 sudo systemctl restart ssh 现在咱们可以在不关闭当前 SSH 连接的情况下新建一个用密钥登录的 SSH 连接。如果登录成功了，就可以断开用密码登录的 SSH 连接了。如果不出意外，现在就不能用密码登录了。 更新系统 # 如果是 Armbian 系统，请先阻止 Armbian 系统的更新。经过小玲实测，截止至 2022 年 12 月 27 日，Nanopi R4S 的 Armbian 系统最稳定的版本是 21.08.1。一些更新的版本都会有一些 bug，例如 LAN 口在系统里消失，WAN 口的接口名称在 eth1 和 eth0 之间反复横跳。 在 Armbian 系统下，编辑 /etc/apt/sources.list.d/armbian.list 文件。 sudo vim /etc/apt/sources.list.d/armbian.list 在这一行前面加个 # ，注释这一行。 #deb http://apt.armbian.com bullseye main bullseye-utils bullseye-desktop 再把 Debian 更新到最新，如果不是 Armbian 系统，直接做这一步就可以了。 sudo apt update sudo apt upgrade -y 设置网络 # 查看一下网络配置文件 cat /etc/network/interfaces 如果是 Armbian 系统，默认内容如下。 source /etc/network/interfaces.d/* # Network is managed by Network manager auto lo iface lo inet loopback 可以看到现在网络的配置是由 NetworkManager 接管的，原本的 Debian 系统是不预装 NetworkManager 的，为了和原本的 Debian 系统设置方法统一，Armbian 系统要把 NetworkManager 卸载掉。这个步骤只是 Armbian 系统才有的，Debian 系统不需要做此步骤。 在卸载 NetworkManager 前，需要先把 /etc/network/interfaces 文件的配置写上。咱们先查看一下接口名称。 ip a 返回如下。小玲自己的 IP 地址和 MAC 地址已打码。 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff inet 192.168.███.███/24 brd 192.168.███.███ scope global dynamic noprefixroute enp1s0 valid_lft 2338sec preferred_lft 2338sec inet6 240█:████:████:████:████:████:████:████/64 scope global dynamic noprefixroute valid_lft 3455sec preferred_lft 3455sec inet6 fe80::362f:579d:8c86:105b/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: eth1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 现在咱们可以看到 LAN 口的接口名称是 enp1s0 ，WAN 口的接口名称是 eth1 ，LAN 口的 IPv6 本地链路地址是 fe80::362f:579d:8c86:105b ，这个地址请记下来，待会可以用到。 编辑 /etc/network/interfaces sudo vim /etc/network/interfaces 将文件改写成现在这个样子。小玲将 IPv4 网段设成了 192.168.3.0/24 。当然网段你也可以改成你喜欢的。 source /etc/network/interfaces.d/* auto lo iface lo inet loopback auto enp1s0 allow-hotplug enp1s0 iface enp1s0 inet static address 192.168.3.1/24 auto eth1 allow-hotplug eth1 iface eth1 inet dhcp iface eth1 inet6 auto 保存好以后就可以卸载 NetworkManager 了。 sudo apt remove -y network-manager sudo apt autoremove -y 开启转发 # 编辑 /etc/sysctl.conf 文件。 sudo vim /etc/sysctl.conf 在 /etc/sysctl.conf 的末尾添加以下内容。 net.ipv4.ip_forward=1 net.ipv6.conf.all.disable_ipv6 = 0 net.ipv6.conf.default.disable_ipv6 = 0 net.ipv6.conf.lo.disable_ipv6 = 0 net.ipv6.conf.all.forwarding=1 net.ipv6.conf.default.forwarding=1 net.ipv6.conf.default.accept_ra=2 net.ipv6.conf.default.use_tempaddr=1 应用配置。 sudo sysctl -p 因为之前咱们更新了系统。现在最好重启一下，顺便应用新的网络设置。 sudo reboot 重启之后 R4S 的 LAN 口的 IP 地址已经变成了 192.168.3.0/24 这个网段了，不能再通过将 R4S 的 LAN 口连接原来的路由器的 LAN 口来获取原来的路由器的 IP 地址了。所以咱们需要使用一条网线连接着 R4S 的 LAN 口和电脑，一条网线连接的原本路由器的 LAN 口和 R4S 的 WAN 口。因为 R4S 上现在还没有 DHCP 服务，所以咱们需要把电脑的 IPv4 地址设为与 R4S 的 LAN 口的 IPv4 地址同一网段的 IPv4 地址。这里咱们就设成 192.168.3.2 ，子网前缀长度是 24 ，网关是 R4S 的 IP 地址 192.168.3.1 。IPv6 先不用管。 设置完电脑的 IP 地址后，通过 SSH 连接到 192.168.3.1 来继续设置 R4S。 安装必要的软件 # 这些软件都是接下来要使用的。 sudo apt install -y nftables pppoeconf 使用 Docker 能减少软件的部署的难度。所以也安装上。 sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose。 sudo wget \"https://github.com/docker/compose/releases/download/v2.14.2/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 配置 Dnsmasq # 创建一个文件夹来存放 Dnsmasq 的配置文件。 mkdir -p ~/config/dnsmasq 编写 dnsmasq.conf 。 vim ~/config/dnsmasq/dnsmasq.conf 写入以下内容。 interface=enp1s0 port=53 server=8.8.8.8 server=8.8.4.4 enable-ra log-dhcp dhcp-range=192.168.3.2,192.168.3.254,1h dhcp-range=::,constructor:enp1s0,ra-stateless,1h dhcp-option=option:router,192.168.3.1 dhcp-option=option:dns-server,192.168.3.1 dhcp-option=option6:dns-server,[fe80::362f:579d:8c86:105b] interface 是 LAN 口的接口名称。 port 是 R4S 上的 DNS 服务的端口，一般都要设为 53 。 server 是上游 DNS 服务器的地址，这里就以谷歌的 DNS 服务器作为例子。 enable-ra 是用于向局域网内分发 IPv6 地址的。 log-dhcp 用于在日志中记录 DHCP 信息。 dhcp-range 是 DHCP 分发 IP 地址的范围，后面的 1h 是过期所需要的时间。 dhcp-option=option:router 是向局域网内宣告的 IPv4 网关地址。 dhcp-option=option:dns-server 是向局域网内宣告的 IPv4 DNS 服务器地址。 dhcp-option=option6:dns-server 是向局域网内宣告的 IPv6 DNS 服务器地址。 编辑 docker-compose.yml 文件，咱们使用 Dnsmasq 的 Docker 版来提供 DNS 和 DHCP 服务。 vim ~/docker-compose.yml 写入以下内容。 version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always 这里的 Dnsmasq 容器必须要使用 host 网络模式， bridge 是不行的。 启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 现在把电脑的 IP 地址从静态改回 DHCP 的。咱们可以发现现在已经可以通过 DHCP 获取 IP 地址了。 PPPoE 拨号 # 现在咱们可以开始连接外网了，咱们把连接 R4S 的 WAN 口的那条网线连接到光猫上。然后执行 sudo pppoeconf 这时候开始扫描哪个接口能连接 PPPoE。 ┌───────────────────┤ SCANNING DEVICE ├────────────────────┐ │ Looking for PPPoE Access Concentrator on enp1s0...       │ │                            66%                           │ └──────────────────────────────────────────────────────────┘ 这里选择 Yes 。 ┌────────────────────────┤ POPULAR OPTIONS ├─────────────────────────┐ │ Most people using popular dialup providers prefer the options      │ │ 'noauth' and 'defaultroute' in their configuration and remove the  │ │ 'nodetach' option. Should I check your configuration file and      │ │ change these settings where neccessary?                            │ │                  <Yes>                     <No>                    │ └────────────────────────────────────────────────────────────────────┘ 这里输入宽带用户名。 ┌────────────────────┤ ENTER USERNAME ├────────────────────┐ │ Please enter the username which you usually need for the │ │ PPP login to your provider in the input box below. If    │ │ you wish to see the help screen, delete the username and │ │ press OK.                                                │ │                                                          │ │ ________________________________________________________ │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 这里输入宽带密码。 ┌────────────────────┤ ENTER PASSWORD ├────────────────────┐ │ Please enter the password which you usually need for the │ │ PPP login to your provider in the input box below.       │ │                                                          │ │ NOTE: you can see the password in plain text while       │ │ typing.                                                  │ │                                                          │ │ ________________________________________________________ │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 这里选 No ，因为咱们已经有 Dnsmasq 了，咱们可以将路由器自身的 DNS 请求交给 Dnsmasq 处理。 ┌─────────────────────┤ USE PEER DNS ├─────────────────────┐ │ You need at least one DNS IP address to resolve the      │ │ normal host names. Normally your provider sends you      │ │ addresses of useable servers when the connection is      │ │ established. Would you like to add these addresses       │ │ automatically to the list of nameservers in your local   │ │ /etc/resolv.conf file? (recommended)                     │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 这里选 Yes 。 ┌──────────────────────┤ LIMITED MSS PROBLEM ├───────────────────────┐ │                                                                    │ │ Many providers have routers that do not support TCP packets with a │ │ MSS higher than 1460. Usually, outgoing packets have this MSS when │ │ they go through one real Ethernet link with the default MTU size   │ │ (1500). Unfortunately, if you are forwarding packets from other    │ │ hosts (i.e. doing masquerading) the MSS may be increased depending │ │ on the packet size and the route to the client hosts, so your      │ │ client machines won't be able to connect to some sites. There is a │ │ solution: the maximum MSS can be limited by pppoe. You can find    │ │ more details about this issue in the pppoe documentation.          │ │                                                                    │ │ Should pppoe clamp MSS at 1452 bytes?                              │ │                                                                    │ │ If unsure, say yes.                                                │ │                                                                    │ │ (If you still get problems described above, try setting to 1412 in │ │ the dsl-provider file.)                                            │ │                                                                    │ │                  <Yes>                     <No>                    │ │                                                                    │ └────────────────────────────────────────────────────────────────────┘ 这里问咱们是否要在开机时自动拨号，作为一个路由器当然要在开机时自动拨号啦。所以咱们选 Yes 。 ┌─────────────────────────┤ DONE ├─────────────────────────┐ │ Your PPPD is configured now. Would you like to start the │ │ connection at boot time?                                 │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 这里告诉咱们可以使用 pon dsl-provider 开启连接；使用 poff 关闭连接。然后问咱们是否现在就开启连接？咱们选择 Yes 。 ┌────────────────┤ ESTABLISH A CONNECTION ├────────────────┐ │ Now, you can make a DSL connection with \"pon             │ │ dsl-provider\" and terminate it with \"poff\". Would you    │ │ like to start the connection now?                        │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 选择 Ok ，结束配置。 ┌─────────────────┤ CONNECTION INITIATED ├─────────────────┐ │ The DSL connection has been triggered. You can use the   │ │ \"plog\" command to see the status or \"ip addr show ppp0\"  │ │ for general interface info.                              │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 现在可以查看一下所有接口的 IP 地址。 ip a 咱们可以看到多了一个名为 ppp0 的接口，并且成功获取了外网的 IP 地址。 4: ppp0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1492 qdisc pfifo_fast state UNKNOWN group default qlen 3 link/ppp inet ███.███.███.███ peer ███.███.███.1/32 scope global ppp0 valid_lft forever preferred_lft forever inet6 240█:████:████:████:████:████:████:████/64 scope global temporary dynamic valid_lft 259127sec preferred_lft 85894sec inet6 240█:████:████:████:████:████:████:████/64 scope global dynamic mngtmpaddr valid_lft 259127sec preferred_lft 172727sec inet6 fe80::████:████:████:████ peer fe80::████:████:████:████/128 scope link valid_lft forever preferred_lft forever 咱们在 R4S 上 ping 一下外网的 IP，已经可以 ping 通。 nanopi-r4s:~:% ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=116 time=19.9 ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=116 time=19.8 ms 但是 ping 域名就不行了。查看一下 /etc/resolv.conf cat /etc/resolv.conf 原来这里的 DNS 还是使用以前的路由器宣告的 DNS。 # Generated by NetworkManager nameserver 192.168.█.1 nameserver fe80::████:████:████:████%enp1s0 编辑 /etc/resolv.conf sudo vim /etc/resolv.conf 将文件内容改为 nameserver ::1 保存后，ping 域名也能 ping 通了，这是因为路由器自身的 DNS 请求已经交给自身的 Dnsmasq 处理了。所以为了路由器自身能正常上网，Dnsmasq 要一直运行着。 但是现在电脑还是不能 ping 通外网的 IPv4 地址 ，这是因为咱们没有做 IPv4 的 NAT 转换。 开启 NAT 转换 # 咱们使用 nftables 来开启 NAT 转换。 编辑 /etc/nftables.conf 文件。 sudo vim /etc/nftables.conf 里面已经写好了一些规则。 #!/usr/sbin/nft -f flush ruleset table inet filter { chain input { type filter hook input priority 0; } chain forward { type filter hook forward priority 0; } chain output { type filter hook output priority 0; } } 咱们把规则修改成这个样子。 #!/usr/sbin/nft -f table inet filter delete table inet filter table inet filter { chain input { type filter hook input priority 0; iifname \"ppp0\" tcp dport { 80, 443 } drop iifname \"ppp0\" udp dport { 53 } drop } chain forward { type filter hook forward priority 0; } chain output { type filter hook output priority 0; } } table ip ipv4-nat delete table ip ipv4-nat table ip ipv4-nat { chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname { eth1, ppp0 } masquerade } } 咱们在 filter 表里的 input 链创建了一条规则 iifname \"ppp0\" tcp dport { 80, 443 } drop 。这条规则的意思是从 ppp0 接口进来的访问 TCP 端口 80 和 443 的数据包全部禁止。设置这条规则的原因是在中国，家宽是不能私自做 WEB 服务的。咱们提前禁止这两个端口从外部的访问。之后就算在路由器上开了 WEB 服务。因为从外部访问不了，就不会有喝茶的风险了。 iifname \"ppp0\" udp dport { 53 } drop 这条规则的意思是禁止从 ppp0 接口进来的对 UDP 端口 53 的访问。因为咱们的 Dnsmasq 只是用来对局域网提供 DNS 服务，没有必要对外网提供 DNS 服务，所以顺便禁止了。 这里咱们创建了一个表 ipv4-nat 。表名前面的 ip 意思是这个表只对 IPv4 有效。然后在表里新建了链 postrouting 。 type nat 的意思是这条链的类型是 nat ； hook postrouting 的意思是这条链会被挂到 postrouting 钩子上； priority srcnat 的意思是这条链的优先级是 srcnat ； policy accept 的意思是这条链的默认规则是“接受”。小玲这么说你可能不太理解，如果你理解 iptables，那么现在的 ipv4-nat 表中的 postrouting 链的功能就和 iptables 中的 nat 表的 POSTROUTING 链的功能差不多。 oifname { eth1, ppp0 } masquerade 的意思是从 eth1 和 ppp0 出去的数据包做 NAT 转换。 table inet filter 和 delete table inet filter 这两句的作用是在使用 sudo systemctl reload nftables 命令重载 nftables 规则时先把已有的表删除再添加，防止规则重复添加。 启动 nftables 服务，这样咱们写的规则就会被加载了，顺便将 nftables 设为自启。 sudo systemctl enable nftables sudo systemctl start nftables 给内网分配 IPv6 地址 # 这时候虽然路由器有公网 IPv6 地址了，可是局域网的设备并没有公网 IPv6 地址。现在咱们要使用 wide-dhcpv6-client 来获取 PD 前缀，这样局域网的设备就能被分配到公网 IPv6 地址了。 创建一个文件夹来存放 wide-dhcpv6-client 的配置文件。 mkdir -p ~/config/wide-dhcpv6-client 编写 dhcp6c.conf 。 vim ~/config/wide-dhcpv6-client/dhcp6c.conf 写入以下内容。 interface ppp0 { send ia-pd 0; }; id-assoc pd 0 { prefix-interface enp1s0 { sla-len 0; ifid 0; }; }; interface ppp0 这里的 ppp0 是连接外网的接口名称。 send ia-pd 0 的意思是发送获取 PD 的请求，并把这个 PD 的 ID 设为 0 。 id-assoc pd 0 的意思是对 ID 为 0 的 PD 进行处理。 prefix-interface enp1s0 的意思是将 PD 前缀绑定到 enp1s0 接口上。这里的接口名称请替换成你的 LAN 口的接口名称。 sla-len 这个值要根据你能获取到的 PD 前缀长度来决定。公式是 64 - 你能获取到的 PD 长度 1 。小玲只能获取到 /64 的前缀。所以小玲的 sla-len 的值为 64-64=0 。 ifid 这个值可以用来固定 LAN 口接口的主机号，把 ifid 设为 0 并且 sla-len 是 0 的话，那么 LAN 口的公网 IPv6 地址将会是 240█:████:████:████:: 。如果不希望这个地址固定，还可以用 if-id-random 来替换这行。 编辑 docker-compose.yml 文件，加入 wide-dhcpv6-client 的配置。 vim ~/docker-compose.yml version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always # 以下是新增的配置。 wide-dhcpv6-client : cap_add : - NET_ADMIN container_name : wide-dhcpv6-client environment : # 这里的 INTERFACE 是连接外网的接口名称。 - INTERFACE=ppp0 image : hoshinorei/wide-dhcpv6-client network_mode : host restart : always volumes : - ./config/wide-dhcpv6-client/dhcp6c.conf:/etc/wide-dhcpv6/dhcp6c.conf:ro 修改完成后，启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 不出意外的话，现在 LAN 口应该能获取到公网 IPv6 地址了。因为咱们前面已经将 Dnsmasq 设置好了，所以局域网的设备应该也能被分配公网 IPv6 地址。 2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff inet 192.168.3.1/24 brd 192.168.3.255 scope global enp1s0 valid_lft forever preferred_lft forever inet6 240█:████:████:████::/64 scope global valid_lft forever preferred_lft forever inet6 fe80::362f:579d:8c86:105b/64 scope link valid_lft forever preferred_lft forever 你可以试试在内网 ping 外网的 IPv6 地址，在外网 ping 内网设备的公网 IPv6 地址。只要没被设备上的防火墙挡住，应该都是可以 ping 通的。 关于 PD 前缀还有一个问题，因为小玲这里的 PPPoE 连接偶尔会自己断一下，虽然 PPPoE 会自动重连，但是断开前获取的 PD 前缀会在重连后无法使用。所以咱们要写一个脚本，在 PPPoE 连接断开时自动删除已有的 PD 前缀，然后 PPPoE 连接成功后自动获取新的 PD 前缀。 在 /etc/ppp/ipv6-down.d/ 文件夹下创建一个脚本，这个脚本小玲就命名为 del_ipv6_pd_prefix 。 sudo vim /etc/ppp/ipv6-down.d/del_ipv6_pd_prefix 写入以下内容。 #!/usr/bin/bash # 这里请替换成你的 LAN 口的接口名称。 INTERFACE = enp1s0 IPV6_ADDRESS = $( ip a show dev $INTERFACE scope global | awk '/inet6/{print $2}' | awk 'NR==1' ) # 这里判断 IPV6_ADDRESS 这个变量是否不为空，不为空则说明有 PD 前缀。 if [[ -n \" $IPV6_ADDRESS \" ]] ; then # 不为空就把 PD 前缀删除。 ip addr del $IPV6_ADDRESS dev $INTERFACE fi exit 0 在 /etc/ppp/ipv6-up.d/ 文件夹下创建一个脚本，这个脚本小玲就命名为 restart_wide-dhcpv6-client 。 sudo vim /etc/ppp/ipv6-up.d/restart_wide-dhcpv6-client 写入以下内容。 #!/bin/sh # 这里的 docker-compose.yml 的路径请改成你自己的，请务必使用绝对路径。 docker-compose -f /home/hoshinorei/docker-compose.yml restart wide-dhcpv6-client exit 0 写入脚本后，赋予它们执行权限。 sudo chmod +x /etc/ppp/ipv6-down.d/del_ipv6_pd_prefix /etc/ppp/ipv6-up.d/restart_wide-dhcpv6-client 理论上，现在就不会因为 PPPoE 连接重连后导致局域网内的设备无法使用 IPv6 了。 UPnP # 咱们最好启用 UPnP 功能，这样电脑上如果有 BT 下载软件，通过 UPnP 映射了端口之后。与别人连接会更容易一点。咱们使用 miniupnpd 来提供 UPnP 服务。 创建一个文件夹来存放 miniupnpd 的配置文件。 mkdir -p ~/config/miniupnpd 编写 miniupnpd.conf 。 vim ~/config/miniupnpd/miniupnpd.conf 写入以下内容。 # 这三行配置的作用是检测路由器是否有公网 IP 或者在不受限制的 NAT 类型下面。 # 如果检测不通过 UPnP 就不会起作用。 ext_perform_stun=yes ext_stun_host=stun.stunprotocol.org ext_stun_port=3478 # 使用系统时间而不是 miniupnpd 的运行时间。 system_uptime=yes # 这里的 UUID 请自己生成 uuid=446cd1fe-9b0b-4527-8f2f-a58f2e7e5504 # WAN 口的接口名称 ext_ifname=ppp0 # 是否启用 UPnP enable_upnp=yes # 是否启用 NAT-PMP enable_natpmp=yes # LAN 口的接口名称 listening_ip=enp1s0 # 这两行的配置的意思是只允许将路由器 WAN 口的 1024-65535 的端口映射到内网任意地址的 1024-65535 端口 allow 1024-65535 0.0.0.0/0 1024-65535 deny 0-65535 0.0.0.0/0 0-65535 allow 的意思是允许哪些端口被映射，你也可以把 allow 改为 deny 来禁止哪些端口被映射。格式都是一样的。 第 1 个 1024-65535 是路由器本身也就是外网能访问的端口范围。 第 2 个 1024-65535 是内网的端口范围。 0.0.0.0/0 是内网的 IPv4 网段，这里设成 0.0.0.0/0 指的是任意网段。 UUID 可以使用这个 网站 生成。 编辑 docker-compose.yml 文件，加入 miniupnpd 的配置。 version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always wide-dhcpv6-client : cap_add : - NET_ADMIN container_name : wide-dhcpv6-client environment : - INTERFACE=ppp0 image : hoshinorei/wide-dhcpv6-client network_mode : host restart : always volumes : - ./config/wide-dhcpv6-client/dhcp6c.conf:/etc/wide-dhcpv6/dhcp6c.conf:ro # 以下是新增的配置。 miniupnpd : cap_add : - NET_ADMIN container_name : miniupnpd image : hoshinorei/miniupnpd network_mode : host restart : always tmpfs : - /run volumes : - ./config/miniupnpd/miniupnpd.conf:/etc/miniupnpd/miniupnpd.conf:ro 修改完成后，启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 结尾 # 好了，你现在拥有了一个能正常上网的软路由啦。不过软路由的强大之处可不止这么点，小玲以后还会带来软路由的更多玩法。另外文章中出现的所有 Docker 镜像都已经开源在 Github ，可以放心使用。 来源： X86 软路由配置 IPv6 踩坑小记 。 ↩︎ 阅读其它文章 ← 使用 Docker 搭建求生之路2的服务器 Windows 上小狼毫输入法的上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/armbian/",
    "title": "Armbian ::\n星野玲的博客",
    "text": "Armbian ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/debian/",
    "title": "Debian ::\n星野玲的博客",
    "text": "Debian ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/nanopi-r4s/",
    "title": "Nanopi R4S ::\n星野玲的博客",
    "text": "Nanopi R4S ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%B7%AF%E7%94%B1%E5%99%A8/",
    "title": "路由器 ::\n星野玲的博客",
    "text": "路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/",
    "title": "软路由 ::\n星野玲的博客",
    "text": "软路由 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/3/",
    "title": "使用 Debian 作为路由器 ::\n星野玲的博客",
    "text": "使用 Debian 作为路由器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。小玲使用一台 Nanopi R4S 作为演示用的设备，刷入的系统为 Armbian 21.08.1，Debian 版本为 11。你也可以用 X86 的设备，设置过程基本上没有区别。 将 Armbian 系统刷入 TF 卡后，咱们将卡插入 R4S 的 TF 卡槽里，使用一条网线接在原本的路由器的 LAN 口上，然后给 R4S 通电。 找到 R4S 通过 DHCP 获取的 IP 地址。用默认用户名 root ，默认密码 1234 登录 SSH。在完成 Armbian 系统的初始设置后，咱们现在得到了一个干净的 Armbian 系统。下面的步骤都是用在 Armbian 系统的初始设置里创建的非 root 用户操作的。小玲不建议大家直接用 root 用户操作。 设置密钥 # 安装完后第一步是要确保路由器安全，因为当设置好后路由器是要暴露在公网上的。有人会扫描 IPv4 的 IP 段，然后再扫描能连通的 IP 地址的端口。如果发现是 SSH 端口，还会爆破。所以咱们要使用密钥文件登录，而且要把密码登录关闭。 创建存放密钥的文件夹，默认路径是家目录下的 .ssh 文件夹。 mkdir ~/.ssh 写入密钥。这里密钥请替换成你自己的。 echo 'ssh-rsa <private_key>' >> ~/.ssh/authorized_keys 编辑 sshd 配置文件。 sudo vim /etc/ssh/sshd_config 将 PermitRootLogin 设为 no 以关闭 root 账号登录；将 PubkeyAuthentication 设为 yes 以开启密钥登录； AuthorizedKeyFile 为密钥路径；将 PasswordAuthentication 设为 no 以关闭密码登录。 PermitRootLogin no PubkeyAuthentication yes AuthorizedKeyFile .ssh/authorized_keys .ssh/authorized_keys2 PasswordAuthentication no 保存后，重启 SSH 服务。 sudo systemctl restart ssh 现在咱们可以在不关闭当前 SSH 连接的情况下新建一个用密钥登录的 SSH 连接。如果登录成功了，就可以断开用密码登录的 SSH 连接了。如果不出意外，现在就不能用密码登录了。 更新系统 # 如果是 Armbian 系统，请先阻止 Armbian 系统的更新。经过小玲实测，截止至 2022 年 12 月 27 日，Nanopi R4S 的 Armbian 系统最稳定的版本是 21.08.1。一些更新的版本都会有一些 bug，例如 LAN 口在系统里消失，WAN 口的接口名称在 eth1 和 eth0 之间反复横跳。 在 Armbian 系统下，编辑 /etc/apt/sources.list.d/armbian.list 文件。 sudo vim /etc/apt/sources.list.d/armbian.list 在这一行前面加个 # ，注释这一行。 #deb http://apt.armbian.com bullseye main bullseye-utils bullseye-desktop 再把 Debian 更新到最新，如果不是 Armbian 系统，直接做这一步就可以了。 sudo apt update sudo apt upgrade -y 设置网络 # 查看一下网络配置文件 cat /etc/network/interfaces 如果是 Armbian 系统，默认内容如下。 source /etc/network/interfaces.d/* # Network is managed by Network manager auto lo iface lo inet loopback 可以看到现在网络的配置是由 NetworkManager 接管的，原本的 Debian 系统是不预装 NetworkManager 的，为了和原本的 Debian 系统设置方法统一，Armbian 系统要把 NetworkManager 卸载掉。这个步骤只是 Armbian 系统才有的，Debian 系统不需要做此步骤。 在卸载 NetworkManager 前，需要先把 /etc/network/interfaces 文件的配置写上。咱们先查看一下接口名称。 ip a 返回如下。小玲自己的 IP 地址和 MAC 地址已打码。 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff inet 192.168.███.███/24 brd 192.168.███.███ scope global dynamic noprefixroute enp1s0 valid_lft 2338sec preferred_lft 2338sec inet6 240█:████:████:████:████:████:████:████/64 scope global dynamic noprefixroute valid_lft 3455sec preferred_lft 3455sec inet6 fe80::362f:579d:8c86:105b/64 scope link noprefixroute valid_lft forever preferred_lft forever 3: eth1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc mq state DOWN group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff 现在咱们可以看到 LAN 口的接口名称是 enp1s0 ，WAN 口的接口名称是 eth1 ，LAN 口的 IPv6 本地链路地址是 fe80::362f:579d:8c86:105b ，这个地址请记下来，待会可以用到。 编辑 /etc/network/interfaces sudo vim /etc/network/interfaces 将文件改写成现在这个样子。小玲将 IPv4 网段设成了 192.168.3.0/24 。当然网段你也可以改成你喜欢的。 source /etc/network/interfaces.d/* auto lo iface lo inet loopback auto enp1s0 allow-hotplug enp1s0 iface enp1s0 inet static address 192.168.3.1/24 auto eth1 allow-hotplug eth1 iface eth1 inet dhcp iface eth1 inet6 auto 保存好以后就可以卸载 NetworkManager 了。 sudo apt remove -y network-manager sudo apt autoremove -y 开启转发 # 编辑 /etc/sysctl.conf 文件。 sudo vim /etc/sysctl.conf 在 /etc/sysctl.conf 的末尾添加以下内容。 net.ipv4.ip_forward=1 net.ipv6.conf.all.disable_ipv6 = 0 net.ipv6.conf.default.disable_ipv6 = 0 net.ipv6.conf.lo.disable_ipv6 = 0 net.ipv6.conf.all.forwarding=1 net.ipv6.conf.default.forwarding=1 net.ipv6.conf.default.accept_ra=2 net.ipv6.conf.default.use_tempaddr=1 应用配置。 sudo sysctl -p 因为之前咱们更新了系统。现在最好重启一下，顺便应用新的网络设置。 sudo reboot 重启之后 R4S 的 LAN 口的 IP 地址已经变成了 192.168.3.0/24 这个网段了，不能再通过将 R4S 的 LAN 口连接原来的路由器的 LAN 口来获取原来的路由器的 IP 地址了。所以咱们需要使用一条网线连接着 R4S 的 LAN 口和电脑，一条网线连接的原本路由器的 LAN 口和 R4S 的 WAN 口。因为 R4S 上现在还没有 DHCP 服务，所以咱们需要把电脑的 IPv4 地址设为与 R4S 的 LAN 口的 IPv4 地址同一网段的 IPv4 地址。这里咱们就设成 192.168.3.2 ，子网前缀长度是 24 ，网关是 R4S 的 IP 地址 192.168.3.1 。IPv6 先不用管。 设置完电脑的 IP 地址后，通过 SSH 连接到 192.168.3.1 来继续设置 R4S。 安装必要的软件 # 这些软件都是接下来要使用的。 sudo apt install -y nftables pppoeconf 使用 Docker 能减少软件的部署的难度。所以也安装上。 sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose。 sudo wget \"https://github.com/docker/compose/releases/download/v2.14.2/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 配置 Dnsmasq # 创建一个文件夹来存放 Dnsmasq 的配置文件。 mkdir -p ~/config/dnsmasq 编写 dnsmasq.conf 。 vim ~/config/dnsmasq/dnsmasq.conf 写入以下内容。 interface=enp1s0 port=53 server=8.8.8.8 server=8.8.4.4 enable-ra log-dhcp dhcp-range=192.168.3.2,192.168.3.254,1h dhcp-range=::,constructor:enp1s0,ra-stateless,1h dhcp-option=option:router,192.168.3.1 dhcp-option=option:dns-server,192.168.3.1 dhcp-option=option6:dns-server,[fe80::362f:579d:8c86:105b] interface 是 LAN 口的接口名称。 port 是 R4S 上的 DNS 服务的端口，一般都要设为 53 。 server 是上游 DNS 服务器的地址，这里就以谷歌的 DNS 服务器作为例子。 enable-ra 是用于向局域网内分发 IPv6 地址的。 log-dhcp 用于在日志中记录 DHCP 信息。 dhcp-range 是 DHCP 分发 IP 地址的范围，后面的 1h 是过期所需要的时间。 dhcp-option=option:router 是向局域网内宣告的 IPv4 网关地址。 dhcp-option=option:dns-server 是向局域网内宣告的 IPv4 DNS 服务器地址。 dhcp-option=option6:dns-server 是向局域网内宣告的 IPv6 DNS 服务器地址。 编辑 docker-compose.yml 文件，咱们使用 Dnsmasq 的 Docker 版来提供 DNS 和 DHCP 服务。 vim ~/docker-compose.yml 写入以下内容。 version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always 这里的 Dnsmasq 容器必须要使用 host 网络模式， bridge 是不行的。 启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 现在把电脑的 IP 地址从静态改回 DHCP 的。咱们可以发现现在已经可以通过 DHCP 获取 IP 地址了。 PPPoE 拨号 # 现在咱们可以开始连接外网了，咱们把连接 R4S 的 WAN 口的那条网线连接到光猫上。然后执行 sudo pppoeconf 这时候开始扫描哪个接口能连接 PPPoE。 ┌───────────────────┤ SCANNING DEVICE ├────────────────────┐ │ Looking for PPPoE Access Concentrator on enp1s0...       │ │                            66%                           │ └──────────────────────────────────────────────────────────┘ 这里选择 Yes 。 ┌────────────────────────┤ POPULAR OPTIONS ├─────────────────────────┐ │ Most people using popular dialup providers prefer the options      │ │ 'noauth' and 'defaultroute' in their configuration and remove the  │ │ 'nodetach' option. Should I check your configuration file and      │ │ change these settings where neccessary?                            │ │                  <Yes>                     <No>                    │ └────────────────────────────────────────────────────────────────────┘ 这里输入宽带用户名。 ┌────────────────────┤ ENTER USERNAME ├────────────────────┐ │ Please enter the username which you usually need for the │ │ PPP login to your provider in the input box below. If    │ │ you wish to see the help screen, delete the username and │ │ press OK.                                                │ │                                                          │ │ ________________________________________________________ │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 这里输入宽带密码。 ┌────────────────────┤ ENTER PASSWORD ├────────────────────┐ │ Please enter the password which you usually need for the │ │ PPP login to your provider in the input box below.       │ │                                                          │ │ NOTE: you can see the password in plain text while       │ │ typing.                                                  │ │                                                          │ │ ________________________________________________________ │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 这里选 No ，因为咱们已经有 Dnsmasq 了，咱们可以将路由器自身的 DNS 请求交给 Dnsmasq 处理。 ┌─────────────────────┤ USE PEER DNS ├─────────────────────┐ │ You need at least one DNS IP address to resolve the      │ │ normal host names. Normally your provider sends you      │ │ addresses of useable servers when the connection is      │ │ established. Would you like to add these addresses       │ │ automatically to the list of nameservers in your local   │ │ /etc/resolv.conf file? (recommended)                     │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 这里选 Yes 。 ┌──────────────────────┤ LIMITED MSS PROBLEM ├───────────────────────┐ │                                                                    │ │ Many providers have routers that do not support TCP packets with a │ │ MSS higher than 1460. Usually, outgoing packets have this MSS when │ │ they go through one real Ethernet link with the default MTU size   │ │ (1500). Unfortunately, if you are forwarding packets from other    │ │ hosts (i.e. doing masquerading) the MSS may be increased depending │ │ on the packet size and the route to the client hosts, so your      │ │ client machines won't be able to connect to some sites. There is a │ │ solution: the maximum MSS can be limited by pppoe. You can find    │ │ more details about this issue in the pppoe documentation.          │ │                                                                    │ │ Should pppoe clamp MSS at 1452 bytes?                              │ │                                                                    │ │ If unsure, say yes.                                                │ │                                                                    │ │ (If you still get problems described above, try setting to 1412 in │ │ the dsl-provider file.)                                            │ │                                                                    │ │                  <Yes>                     <No>                    │ │                                                                    │ └────────────────────────────────────────────────────────────────────┘ 这里问咱们是否要在开机时自动拨号，作为一个路由器当然要在开机时自动拨号啦。所以咱们选 Yes 。 ┌─────────────────────────┤ DONE ├─────────────────────────┐ │ Your PPPD is configured now. Would you like to start the │ │ connection at boot time?                                 │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 这里告诉咱们可以使用 pon dsl-provider 开启连接；使用 poff 关闭连接。然后问咱们是否现在就开启连接？咱们选择 Yes 。 ┌────────────────┤ ESTABLISH A CONNECTION ├────────────────┐ │ Now, you can make a DSL connection with \"pon             │ │ dsl-provider\" and terminate it with \"poff\". Would you    │ │ like to start the connection now?                        │ │               <Yes>                  <No>                │ └──────────────────────────────────────────────────────────┘ 选择 Ok ，结束配置。 ┌─────────────────┤ CONNECTION INITIATED ├─────────────────┐ │ The DSL connection has been triggered. You can use the   │ │ \"plog\" command to see the status or \"ip addr show ppp0\"  │ │ for general interface info.                              │ │                          <Ok>                            │ └──────────────────────────────────────────────────────────┘ 现在可以查看一下所有接口的 IP 地址。 ip a 咱们可以看到多了一个名为 ppp0 的接口，并且成功获取了外网的 IP 地址。 4: ppp0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1492 qdisc pfifo_fast state UNKNOWN group default qlen 3 link/ppp inet ███.███.███.███ peer ███.███.███.1/32 scope global ppp0 valid_lft forever preferred_lft forever inet6 240█:████:████:████:████:████:████:████/64 scope global temporary dynamic valid_lft 259127sec preferred_lft 85894sec inet6 240█:████:████:████:████:████:████:████/64 scope global dynamic mngtmpaddr valid_lft 259127sec preferred_lft 172727sec inet6 fe80::████:████:████:████ peer fe80::████:████:████:████/128 scope link valid_lft forever preferred_lft forever 咱们在 R4S 上 ping 一下外网的 IP，已经可以 ping 通。 nanopi-r4s:~:% ping 8.8.8.8 PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data. 64 bytes from 8.8.8.8: icmp_seq=1 ttl=116 time=19.9 ms 64 bytes from 8.8.8.8: icmp_seq=2 ttl=116 time=19.8 ms 但是 ping 域名就不行了。查看一下 /etc/resolv.conf cat /etc/resolv.conf 原来这里的 DNS 还是使用以前的路由器宣告的 DNS。 # Generated by NetworkManager nameserver 192.168.█.1 nameserver fe80::████:████:████:████%enp1s0 编辑 /etc/resolv.conf sudo vim /etc/resolv.conf 将文件内容改为 nameserver ::1 保存后，ping 域名也能 ping 通了，这是因为路由器自身的 DNS 请求已经交给自身的 Dnsmasq 处理了。所以为了路由器自身能正常上网，Dnsmasq 要一直运行着。 但是现在电脑还是不能 ping 通外网的 IPv4 地址 ，这是因为咱们没有做 IPv4 的 NAT 转换。 开启 NAT 转换 # 咱们使用 nftables 来开启 NAT 转换。 编辑 /etc/nftables.conf 文件。 sudo vim /etc/nftables.conf 里面已经写好了一些规则。 #!/usr/sbin/nft -f flush ruleset table inet filter { chain input { type filter hook input priority 0; } chain forward { type filter hook forward priority 0; } chain output { type filter hook output priority 0; } } 咱们把规则修改成这个样子。 #!/usr/sbin/nft -f table inet filter delete table inet filter table inet filter { chain input { type filter hook input priority 0; iifname \"ppp0\" tcp dport { 80, 443 } drop iifname \"ppp0\" udp dport { 53 } drop } chain forward { type filter hook forward priority 0; } chain output { type filter hook output priority 0; } } table ip ipv4-nat delete table ip ipv4-nat table ip ipv4-nat { chain postrouting { type nat hook postrouting priority srcnat; policy accept; oifname { eth1, ppp0 } masquerade } } 咱们在 filter 表里的 input 链创建了一条规则 iifname \"ppp0\" tcp dport { 80, 443 } drop 。这条规则的意思是从 ppp0 接口进来的访问 TCP 端口 80 和 443 的数据包全部禁止。设置这条规则的原因是在中国，家宽是不能私自做 WEB 服务的。咱们提前禁止这两个端口从外部的访问。之后就算在路由器上开了 WEB 服务。因为从外部访问不了，就不会有喝茶的风险了。 iifname \"ppp0\" udp dport { 53 } drop 这条规则的意思是禁止从 ppp0 接口进来的对 UDP 端口 53 的访问。因为咱们的 Dnsmasq 只是用来对局域网提供 DNS 服务，没有必要对外网提供 DNS 服务，所以顺便禁止了。 这里咱们创建了一个表 ipv4-nat 。表名前面的 ip 意思是这个表只对 IPv4 有效。然后在表里新建了链 postrouting 。 type nat 的意思是这条链的类型是 nat ； hook postrouting 的意思是这条链会被挂到 postrouting 钩子上； priority srcnat 的意思是这条链的优先级是 srcnat ； policy accept 的意思是这条链的默认规则是“接受”。小玲这么说你可能不太理解，如果你理解 iptables，那么现在的 ipv4-nat 表中的 postrouting 链的功能就和 iptables 中的 nat 表的 POSTROUTING 链的功能差不多。 oifname { eth1, ppp0 } masquerade 的意思是从 eth1 和 ppp0 出去的数据包做 NAT 转换。 table inet filter 和 delete table inet filter 这两句的作用是在使用 sudo systemctl reload nftables 命令重载 nftables 规则时先把已有的表删除再添加，防止规则重复添加。 启动 nftables 服务，这样咱们写的规则就会被加载了，顺便将 nftables 设为自启。 sudo systemctl enable nftables sudo systemctl start nftables 给内网分配 IPv6 地址 # 这时候虽然路由器有公网 IPv6 地址了，可是局域网的设备并没有公网 IPv6 地址。现在咱们要使用 wide-dhcpv6-client 来获取 PD 前缀，这样局域网的设备就能被分配到公网 IPv6 地址了。 创建一个文件夹来存放 wide-dhcpv6-client 的配置文件。 mkdir -p ~/config/wide-dhcpv6-client 编写 dhcp6c.conf 。 vim ~/config/wide-dhcpv6-client/dhcp6c.conf 写入以下内容。 interface ppp0 { send ia-pd 0; }; id-assoc pd 0 { prefix-interface enp1s0 { sla-len 0; ifid 0; }; }; interface ppp0 这里的 ppp0 是连接外网的接口名称。 send ia-pd 0 的意思是发送获取 PD 的请求，并把这个 PD 的 ID 设为 0 。 id-assoc pd 0 的意思是对 ID 为 0 的 PD 进行处理。 prefix-interface enp1s0 的意思是将 PD 前缀绑定到 enp1s0 接口上。这里的接口名称请替换成你的 LAN 口的接口名称。 sla-len 这个值要根据你能获取到的 PD 前缀长度来决定。公式是 64 - 你能获取到的 PD 长度 1 。小玲只能获取到 /64 的前缀。所以小玲的 sla-len 的值为 64-64=0 。 ifid 这个值可以用来固定 LAN 口接口的主机号，把 ifid 设为 0 并且 sla-len 是 0 的话，那么 LAN 口的公网 IPv6 地址将会是 240█:████:████:████:: 。如果不希望这个地址固定，还可以用 if-id-random 来替换这行。 编辑 docker-compose.yml 文件，加入 wide-dhcpv6-client 的配置。 vim ~/docker-compose.yml version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always # 以下是新增的配置。 wide-dhcpv6-client : cap_add : - NET_ADMIN container_name : wide-dhcpv6-client environment : # 这里的 INTERFACE 是连接外网的接口名称。 - INTERFACE=ppp0 image : hoshinorei/wide-dhcpv6-client network_mode : host restart : always volumes : - ./config/wide-dhcpv6-client/dhcp6c.conf:/etc/wide-dhcpv6/dhcp6c.conf:ro 修改完成后，启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 不出意外的话，现在 LAN 口应该能获取到公网 IPv6 地址了。因为咱们前面已经将 Dnsmasq 设置好了，所以局域网的设备应该也能被分配公网 IPv6 地址。 2: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000 link/ether ██:██:██:██:██:██ brd ff:ff:ff:ff:ff:ff inet 192.168.3.1/24 brd 192.168.3.255 scope global enp1s0 valid_lft forever preferred_lft forever inet6 240█:████:████:████::/64 scope global valid_lft forever preferred_lft forever inet6 fe80::362f:579d:8c86:105b/64 scope link valid_lft forever preferred_lft forever 你可以试试在内网 ping 外网的 IPv6 地址，在外网 ping 内网设备的公网 IPv6 地址。只要没被设备上的防火墙挡住，应该都是可以 ping 通的。 关于 PD 前缀还有一个问题，因为小玲这里的 PPPoE 连接偶尔会自己断一下，虽然 PPPoE 会自动重连，但是断开前获取的 PD 前缀会在重连后无法使用。所以咱们要写一个脚本，在 PPPoE 连接断开时自动删除已有的 PD 前缀，然后 PPPoE 连接成功后自动获取新的 PD 前缀。 在 /etc/ppp/ipv6-down.d/ 文件夹下创建一个脚本，这个脚本小玲就命名为 del_ipv6_pd_prefix 。 sudo vim /etc/ppp/ipv6-down.d/del_ipv6_pd_prefix 写入以下内容。 #!/usr/bin/bash # 这里请替换成你的 LAN 口的接口名称。 INTERFACE = enp1s0 IPV6_ADDRESS = $( ip a show dev $INTERFACE scope global | awk '/inet6/{print $2}' | awk 'NR==1' ) # 这里判断 IPV6_ADDRESS 这个变量是否不为空，不为空则说明有 PD 前缀。 if [[ -n \" $IPV6_ADDRESS \" ]] ; then # 不为空就把 PD 前缀删除。 ip addr del $IPV6_ADDRESS dev $INTERFACE fi exit 0 在 /etc/ppp/ipv6-up.d/ 文件夹下创建一个脚本，这个脚本小玲就命名为 restart_wide-dhcpv6-client 。 sudo vim /etc/ppp/ipv6-up.d/restart_wide-dhcpv6-client 写入以下内容。 #!/bin/sh # 这里的 docker-compose.yml 的路径请改成你自己的，请务必使用绝对路径。 docker-compose -f /home/hoshinorei/docker-compose.yml restart wide-dhcpv6-client exit 0 写入脚本后，赋予它们执行权限。 sudo chmod +x /etc/ppp/ipv6-down.d/del_ipv6_pd_prefix /etc/ppp/ipv6-up.d/restart_wide-dhcpv6-client 理论上，现在就不会因为 PPPoE 连接重连后导致局域网内的设备无法使用 IPv6 了。 UPnP # 咱们最好启用 UPnP 功能，这样电脑上如果有 BT 下载软件，通过 UPnP 映射了端口之后。与别人连接会更容易一点。咱们使用 miniupnpd 来提供 UPnP 服务。 创建一个文件夹来存放 miniupnpd 的配置文件。 mkdir -p ~/config/miniupnpd 编写 miniupnpd.conf 。 vim ~/config/miniupnpd/miniupnpd.conf 写入以下内容。 # 这三行配置的作用是检测路由器是否有公网 IP 或者在不受限制的 NAT 类型下面。 # 如果检测不通过 UPnP 就不会起作用。 ext_perform_stun=yes ext_stun_host=stun.stunprotocol.org ext_stun_port=3478 # 使用系统时间而不是 miniupnpd 的运行时间。 system_uptime=yes # 这里的 UUID 请自己生成 uuid=446cd1fe-9b0b-4527-8f2f-a58f2e7e5504 # WAN 口的接口名称 ext_ifname=ppp0 # 是否启用 UPnP enable_upnp=yes # 是否启用 NAT-PMP enable_natpmp=yes # LAN 口的接口名称 listening_ip=enp1s0 # 这两行的配置的意思是只允许将路由器 WAN 口的 1024-65535 的端口映射到内网任意地址的 1024-65535 端口 allow 1024-65535 0.0.0.0/0 1024-65535 deny 0-65535 0.0.0.0/0 0-65535 allow 的意思是允许哪些端口被映射，你也可以把 allow 改为 deny 来禁止哪些端口被映射。格式都是一样的。 第 1 个 1024-65535 是路由器本身也就是外网能访问的端口范围。 第 2 个 1024-65535 是内网的端口范围。 0.0.0.0/0 是内网的 IPv4 网段，这里设成 0.0.0.0/0 指的是任意网段。 UUID 可以使用这个 网站 生成。 编辑 docker-compose.yml 文件，加入 miniupnpd 的配置。 version : \"3\" services : dnsmasq : container_name : dnsmasq cap_add : - NET_ADMIN image : hoshinorei/dnsmasq network_mode : host volumes : - ./config/dnsmasq/dnsmasq.conf:/etc/dnsmasq.conf:ro restart : always wide-dhcpv6-client : cap_add : - NET_ADMIN container_name : wide-dhcpv6-client environment : - INTERFACE=ppp0 image : hoshinorei/wide-dhcpv6-client network_mode : host restart : always volumes : - ./config/wide-dhcpv6-client/dhcp6c.conf:/etc/wide-dhcpv6/dhcp6c.conf:ro # 以下是新增的配置。 miniupnpd : cap_add : - NET_ADMIN container_name : miniupnpd image : hoshinorei/miniupnpd network_mode : host restart : always tmpfs : - /run volumes : - ./config/miniupnpd/miniupnpd.conf:/etc/miniupnpd/miniupnpd.conf:ro 修改完成后，启动容器。 sudo docker-compose -f ~/docker-compose.yml up -d 结尾 # 好了，你现在拥有了一个能正常上网的软路由啦。不过软路由的强大之处可不止这么点，小玲以后还会带来软路由的更多玩法。另外文章中出现的所有 Docker 镜像都已经开源在 Github ，可以放心使用。 来源： X86 软路由配置 IPv6 踩坑小记 。 ↩︎ 阅读其它文章 ← 使用 Docker 搭建求生之路2的服务器 Windows 上小狼毫输入法的上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/",
    "title": "星野玲的博客",
    "text": "星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → 使用 NetworkManager 配置 Debian 路由器 2023-10-01 (最后修改于：\n2023-11-24) — 作者： 星野玲 #Debian #路由器 #软路由 大约一年半前，小玲写了《使用 Debian 作为路由器》这篇文章。由于 Armbian 自带了 NetworkManager 而 Debian 没有自带 NetworkManager，所以当时小玲一开始就把 NetworkManager 卸载了，不过现在小玲打算用上 NetworkManager。 阅读更多 → 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 阅读更多 → Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 2022-08-10 (最后修改于：\n2024-08-26) — 作者： 星野玲 #Debian #华硕AX86U #路由器 #软路由 小玲有这样一个需求，一个无线路由器能发出多个 SSID 的 WiFi，并且连接一个 SSID 的 WiFi 的设备与连接另一个 SSID 的 WiFi 的设备之间的通信可以隔离。这里的隔离不是“禁止无线用户互通”，而是要 VLAN 隔离。 阅读更多 → 较旧的文章 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/20/",
    "title": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客",
    "text": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲以前没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 fnm 是使用 Rust 编写的，意味着咱们可以在 Linux、macOS、Windows 上都能使用 fnm。这里小玲就拿 Windows 作为例子。 安装 # 使用 Scoop 安装 fnm 。 scoop install main/fnm 安装好后，需要往 $profile 文件加一行命令使得 fnm 在 PowerShell 中生效，小玲就用 VSCode 编辑 $profile 了。如果没有安装 VSCode，可以通过 scoop install extras/vscode 安装。 code $profile 在最后一行添加下面的命令。 fnm env --use-on-cd | Out-String | Invoke-Expression 设置镜像 # fnm 默认是从 Node.js 官网下载的，有时候下载会特别慢。咱们可以使用下面的命令设置环境变量，将源设置成国内阿里云的。 [ Environment ]::SetEnvironmentVariable( 'FNM_NODE_DIST_MIRROR' , 'https://mirrors.aliyun.com/nodejs-release/' , 'User' ); 使用上面的命令设置了环境变量之后，请重启终端使环境变量生效。 版本号 # 在 fnm 里，Node.js 的版本号是可以省略小版本号的，省略了小版本号之后，剩下大版本号是指这个大版本下的最新一个小版本。 例如最新的 Node.js 版本是 20.8.1 ， 20.8 就等同于 20.8.1 而不是 20.8.0 。 20 就等同于 20.8 而不是 20.7 、 20.6 以及更低的版本。 安装最新的 Node.js # fnm install --latest 安装任意一个版本的 Node.js # fnm install <version> 例如 fnm install 20 卸载任意一个版本的 Node.js # fnm uninstall <version> 卸载时，如果执行 fnm uninstall 20 ，但是已经安装了两个或以上的 20 大版本的 Node.js，这时候就需要把版本号写更精确一些。 查看当前安装了哪些版本 # fnm ls 标有 default 的版本是当前正在使用的版本。 查看可以安装哪些版本 # fnm ls-remote 使用某个版本 # fnm use <version> 将当前使用的版本添加到 Path 环境变量 # 虽然咱们能在 PowerShell 使用 node 命令了，但是咱们并没有把 node 命令所在的文件夹加入 Path 环境变量，这样 WebStorm 就没有识别到使用 fnm 安装的 Node.js。 解决方法也很简单，使用下面的命令把路径添加到 Path 环境变量就可以了。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; $env:APPDATA \\fnm\\aliases\\default\" , 'User' ) 如果 WebStorm 里还是没有识别到，可以试试重启系统。 阅读其它文章 使用 NetworkManager 配置 Debian 路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/fnm/",
    "title": "fnm ::\n星野玲的博客",
    "text": "fnm ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/nodejs/",
    "title": "NodeJS ::\n星野玲的博客",
    "text": "NodeJS ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows/",
    "title": "Windows ::\n星野玲的博客",
    "text": "Windows ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/20/",
    "title": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客",
    "text": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲以前没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 fnm 是使用 Rust 编写的，意味着咱们可以在 Linux、macOS、Windows 上都能使用 fnm。这里小玲就拿 Windows 作为例子。 安装 # 使用 Scoop 安装 fnm 。 scoop install main/fnm 安装好后，需要往 $profile 文件加一行命令使得 fnm 在 PowerShell 中生效，小玲就用 VSCode 编辑 $profile 了。如果没有安装 VSCode，可以通过 scoop install extras/vscode 安装。 code $profile 在最后一行添加下面的命令。 fnm env --use-on-cd | Out-String | Invoke-Expression 设置镜像 # fnm 默认是从 Node.js 官网下载的，有时候下载会特别慢。咱们可以使用下面的命令设置环境变量，将源设置成国内阿里云的。 [ Environment ]::SetEnvironmentVariable( 'FNM_NODE_DIST_MIRROR' , 'https://mirrors.aliyun.com/nodejs-release/' , 'User' ); 使用上面的命令设置了环境变量之后，请重启终端使环境变量生效。 版本号 # 在 fnm 里，Node.js 的版本号是可以省略小版本号的，省略了小版本号之后，剩下大版本号是指这个大版本下的最新一个小版本。 例如最新的 Node.js 版本是 20.8.1 ， 20.8 就等同于 20.8.1 而不是 20.8.0 。 20 就等同于 20.8 而不是 20.7 、 20.6 以及更低的版本。 安装最新的 Node.js # fnm install --latest 安装任意一个版本的 Node.js # fnm install <version> 例如 fnm install 20 卸载任意一个版本的 Node.js # fnm uninstall <version> 卸载时，如果执行 fnm uninstall 20 ，但是已经安装了两个或以上的 20 大版本的 Node.js，这时候就需要把版本号写更精确一些。 查看当前安装了哪些版本 # fnm ls 标有 default 的版本是当前正在使用的版本。 查看可以安装哪些版本 # fnm ls-remote 使用某个版本 # fnm use <version> 将当前使用的版本添加到 Path 环境变量 # 虽然咱们能在 PowerShell 使用 node 命令了，但是咱们并没有把 node 命令所在的文件夹加入 Path 环境变量，这样 WebStorm 就没有识别到使用 fnm 安装的 Node.js。 解决方法也很简单，使用下面的命令把路径添加到 Path 环境变量就可以了。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; $env:APPDATA \\fnm\\aliases\\default\" , 'User' ) 如果 WebStorm 里还是没有识别到，可以试试重启系统。 阅读其它文章 使用 NetworkManager 配置 Debian 路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/18/",
    "title": "关于 router.push() 会报错这件事 ::\n星野玲的博客",
    "text": "关于 router.push() 会报错这件事 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 这是一个 vue 文件，看似没有什么问题。 < template > <!-- 创建一个退出登录按钮 --> < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' // 定义一个名为logout的函数，用于处理退出登录的逻辑 function logout () { // 显示一个退出登录成功的消息提示框 ElMessage ({ message : '退出登录成功' , // 在消息提示框关闭时执行回调函数 onClose : async () => { // 获取Vue Router实例 const router = useRouter () // 执行路由跳转，跳转到名为'login'的路由 await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 不过，咱们把它运行起来，在点击退出登录按钮后，并没有成功跳转到名为 login 的路由，控制台报错： Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'push') 看样子， router 这个常量是 undefined 的。按理来说不应该呀，根据 文档 ，通过调用 useRouter() 函数应该会返回一个 Vue Router 实例。 小玲想了想，会不会是 const router = useRouter() 这个语句的位置不对，小玲把它放在这里的理由是 router 常量第一次使用的时候就是在这，想着挨近一点比较好。于是小玲移动 const router = useRouter() 到 onClose 外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' function logout () { const router = useRouter () ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 还是不行，那再移动到 lougot() 函数外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' const router = useRouter () function logout () { ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 这次就正常了，小玲后来搜了搜，原来已经 有人遇到过这个问题了 。总而言之， useRouter() 一定要在 script 标签里的顶层调用。 至于为什么， 文档 里有提到 useRouter() 是用来替代以前的写法中的 this.$router 。 因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route 。作为替代，我们使用 useRouter 和 useRoute 函数。 假设咱们还在使用以前的写法，如果不放在顶层，那么这个 this 指向谁呢？相信聪明的你一定能理解小玲的意思，小玲就不再赘述了。 阅读其它文章 ← 使用 NetworkManager 配置 Debian 路由器 Docker 下的 Traefik 上手教程（二） → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/vue/",
    "title": "Vue ::\n星野玲的博客",
    "text": "Vue ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/vue3/",
    "title": "Vue3 ::\n星野玲的博客",
    "text": "Vue3 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/vue-router/",
    "title": "Vue Router ::\n星野玲的博客",
    "text": "Vue Router ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/18/",
    "title": "关于 router.push() 会报错这件事 ::\n星野玲的博客",
    "text": "关于 router.push() 会报错这件事 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 这是一个 vue 文件，看似没有什么问题。 < template > <!-- 创建一个退出登录按钮 --> < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' // 定义一个名为logout的函数，用于处理退出登录的逻辑 function logout () { // 显示一个退出登录成功的消息提示框 ElMessage ({ message : '退出登录成功' , // 在消息提示框关闭时执行回调函数 onClose : async () => { // 获取Vue Router实例 const router = useRouter () // 执行路由跳转，跳转到名为'login'的路由 await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 不过，咱们把它运行起来，在点击退出登录按钮后，并没有成功跳转到名为 login 的路由，控制台报错： Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'push') 看样子， router 这个常量是 undefined 的。按理来说不应该呀，根据 文档 ，通过调用 useRouter() 函数应该会返回一个 Vue Router 实例。 小玲想了想，会不会是 const router = useRouter() 这个语句的位置不对，小玲把它放在这里的理由是 router 常量第一次使用的时候就是在这，想着挨近一点比较好。于是小玲移动 const router = useRouter() 到 onClose 外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' function logout () { const router = useRouter () ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 还是不行，那再移动到 lougot() 函数外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' const router = useRouter () function logout () { ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 这次就正常了，小玲后来搜了搜，原来已经 有人遇到过这个问题了 。总而言之， useRouter() 一定要在 script 标签里的顶层调用。 至于为什么， 文档 里有提到 useRouter() 是用来替代以前的写法中的 this.$router 。 因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route 。作为替代，我们使用 useRouter 和 useRoute 函数。 假设咱们还在使用以前的写法，如果不放在顶层，那么这个 this 指向谁呢？相信聪明的你一定能理解小玲的意思，小玲就不再赘述了。 阅读其它文章 ← 使用 NetworkManager 配置 Debian 路由器 Docker 下的 Traefik 上手教程（二） → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/15/",
    "title": "Docker 下的 Traefik 上手教程（二） ::\n星野玲的博客",
    "text": "Docker 下的 Traefik 上手教程（二） ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。因为看过上一篇文章的你已经知道修改 docker-compose.yml 后都要 docker compose up 一下了，所以这篇文章就不再提到这个命令了。 middleware # 咱们在使用 Traefik 时，一般都会用到 middleware。比如咱们可以通过中间件让访问者浏览 HTTP 协议的地址时，自动跳转到 HTTPS 协议，或者开启压缩以节省服务器的带宽。下面就用这两个例子来讲解如何使用 middleware。 首先咱们需要定义一个 middleware。在这里需要注意一点的就是在 docker-compose.yml 的 labels 里定义的 route 要想使用在文件里定义的 middleware 时，需要在 middleware 的名称后加上 @file 。反之在文件里定义的 route 要想使用在 docker-compose.yml 的 labels 里定义的 middleware 时，需要在 middleware 的名称后加上 @docker 。 1 关于这一点，下面会有例子解释。 HTTP 跳转 HTTPS # 如果需要在 docker-compose.yml 的 labels 里定义 middleware，咱们可以在 Traefik 的 docker-compose.yml 文件里这样子写。 version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" # 下面未注释的 2 行是新增的内容 labels : # 声明一个名为 redirect-to-https 的 middleware # 在名为 redirect-to-https 的 middleware 下，将 redirectscheme 的 scheme 设置为 \"https\" - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 然后修改服务的 labels，让服务使用这个 middleware。 version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web # 下面未注释的 2 行是新增的内容 # 在名为 whoami 的 route 下，将 middlewares 设置为 \"redirect-to-https\" # 如果有多个 middleware，可以用英文逗号分隔 - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver networks : - traefik_default networks : traefik_default : external : true 启用压缩 # Traefik 3.0 支持 gzip 和 Brotli 压缩。 如果需要在文件里定义 middleware，咱们可以在 Traefik 的 docker-compose.yml 文件里这样子写。 vim ~/docker_config/traefik/middlewares.yml http : middlewares : # 定义一个名为 compression 的 middleware compression : # 名为 compression 的 middleware 里包含了 compress 这个 middleware compress : {} version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver # 下面未注释的 1 行是新增的内容 # 在名为 whoami-secured 的 route 下，将 middlewares 设置为 \"compression@file\" - traefik.http.routers.whoami-secured.middlewares=compression@file networks : - traefik_default networks : traefik_default : external : true HTTP Basic Authentication # 咱们首先要通过一个命令将用户名变成一段 Traefik 可以识别的字符串。 使用这个命令前，咱们需要安装 apache2-utils 。 apt install -y apache2-utils echo $( htpasswd -nB <username> ) | sed -e s/ \\\\ $/ \\\\ $ \\\\ $/g 咱们以用户名 test ，密码 123456 为例。 echo $( htpasswd -nB test ) | sed -e s/ \\\\ $/ \\\\ $ \\\\ $/g 输入两次密码后，返回 test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver # 下面未注释的 1 行是修改的内容 # 在名为 whoami-secured 的 route 下，将 middlewares 设置为 \"compression@file,test-auth\" - traefik.http.routers.whoami-secured.middlewares=compression@file,test-auth # 下面未注释的 1 行是新增的内容 # 声明一个名为 test-auth 的 middleware # 在名为 test-auth 的 middleware 下，将 basicauth 的 users 设置为 \"test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq\" # 如果有多个用户，可以用英文逗号分隔 - traefik.http.middlewares.test-auth.basicauth.users=test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq networks : - traefik_default networks : traefik_default : external : true 启用 HTTP/3 # 如果要启用 HTTP/3，只需在 Traefik 的 docker-compose.yml 文件的 command 里加上这两行就可以了。 version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 # 下面未注释的 2 行是新增的内容 # 在名为 websecure 的 entrypoint 下，开启 HTTP/3 - -- entrypoints.websecure.http3 # 在名为 websecure 的 entrypoint 下，将 http3 的 advertisedPort 设置为 443 - -- entrypoints.websecure.http3.advertisedPort=443 - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" labels : - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 # 下面未注释的 1 行是新增的内容 # 443 端口也要映射 UDP 协议 - 443 : 443 /udp - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 来源： Provider Namespace 。 ↩︎ 阅读其它文章 ← 关于 router.push() 会报错这件事 Docker 下的 Traefik 上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker/",
    "title": "Docker ::\n星野玲的博客",
    "text": "Docker ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker-compose/",
    "title": "Docker Compose ::\n星野玲的博客",
    "text": "Docker Compose ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/traefik/",
    "title": "Traefik ::\n星野玲的博客",
    "text": "Traefik ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/15/",
    "title": "Docker 下的 Traefik 上手教程（二） ::\n星野玲的博客",
    "text": "Docker 下的 Traefik 上手教程（二） ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。因为看过上一篇文章的你已经知道修改 docker-compose.yml 后都要 docker compose up 一下了，所以这篇文章就不再提到这个命令了。 middleware # 咱们在使用 Traefik 时，一般都会用到 middleware。比如咱们可以通过中间件让访问者浏览 HTTP 协议的地址时，自动跳转到 HTTPS 协议，或者开启压缩以节省服务器的带宽。下面就用这两个例子来讲解如何使用 middleware。 首先咱们需要定义一个 middleware。在这里需要注意一点的就是在 docker-compose.yml 的 labels 里定义的 route 要想使用在文件里定义的 middleware 时，需要在 middleware 的名称后加上 @file 。反之在文件里定义的 route 要想使用在 docker-compose.yml 的 labels 里定义的 middleware 时，需要在 middleware 的名称后加上 @docker 。 1 关于这一点，下面会有例子解释。 HTTP 跳转 HTTPS # 如果需要在 docker-compose.yml 的 labels 里定义 middleware，咱们可以在 Traefik 的 docker-compose.yml 文件里这样子写。 version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" # 下面未注释的 2 行是新增的内容 labels : # 声明一个名为 redirect-to-https 的 middleware # 在名为 redirect-to-https 的 middleware 下，将 redirectscheme 的 scheme 设置为 \"https\" - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 然后修改服务的 labels，让服务使用这个 middleware。 version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web # 下面未注释的 2 行是新增的内容 # 在名为 whoami 的 route 下，将 middlewares 设置为 \"redirect-to-https\" # 如果有多个 middleware，可以用英文逗号分隔 - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver networks : - traefik_default networks : traefik_default : external : true 启用压缩 # Traefik 3.0 支持 gzip 和 Brotli 压缩。 如果需要在文件里定义 middleware，咱们可以在 Traefik 的 docker-compose.yml 文件里这样子写。 vim ~/docker_config/traefik/middlewares.yml http : middlewares : # 定义一个名为 compression 的 middleware compression : # 名为 compression 的 middleware 里包含了 compress 这个 middleware compress : {} version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver # 下面未注释的 1 行是新增的内容 # 在名为 whoami-secured 的 route 下，将 middlewares 设置为 \"compression@file\" - traefik.http.routers.whoami-secured.middlewares=compression@file networks : - traefik_default networks : traefik_default : external : true HTTP Basic Authentication # 咱们首先要通过一个命令将用户名变成一段 Traefik 可以识别的字符串。 使用这个命令前，咱们需要安装 apache2-utils 。 apt install -y apache2-utils echo $( htpasswd -nB <username> ) | sed -e s/ \\\\ $/ \\\\ $ \\\\ $/g 咱们以用户名 test ，密码 123456 为例。 echo $( htpasswd -nB test ) | sed -e s/ \\\\ $/ \\\\ $ \\\\ $/g 输入两次密码后，返回 test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami.middlewares=redirect-to-https - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure - traefik.http.routers.whoami-secured.tls.certresolver=myresolver # 下面未注释的 1 行是修改的内容 # 在名为 whoami-secured 的 route 下，将 middlewares 设置为 \"compression@file,test-auth\" - traefik.http.routers.whoami-secured.middlewares=compression@file,test-auth # 下面未注释的 1 行是新增的内容 # 声明一个名为 test-auth 的 middleware # 在名为 test-auth 的 middleware 下，将 basicauth 的 users 设置为 \"test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq\" # 如果有多个用户，可以用英文逗号分隔 - traefik.http.middlewares.test-auth.basicauth.users=test:$$2y$$05$$SkpWa0Cx2rEoAEapv19Mjub.SaEmo7tJ5TqagI7ZqCNEPms5M0zUq networks : - traefik_default networks : traefik_default : external : true 启用 HTTP/3 # 如果要启用 HTTP/3，只需在 Traefik 的 docker-compose.yml 文件的 command 里加上这两行就可以了。 version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 # 下面未注释的 2 行是新增的内容 # 在名为 websecure 的 entrypoint 下，开启 HTTP/3 - -- entrypoints.websecure.http3 # 在名为 websecure 的 entrypoint 下，将 http3 的 advertisedPort 设置为 443 - -- entrypoints.websecure.http3.advertisedPort=443 - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" labels : - traefik.http.middlewares.redirect-to-https.redirectscheme.scheme=https image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 # 下面未注释的 1 行是新增的内容 # 443 端口也要映射 UDP 协议 - 443 : 443 /udp - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 来源： Provider Namespace 。 ↩︎ 阅读其它文章 ← 关于 router.push() 会报错这件事 Docker 下的 Traefik 上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/14/",
    "title": "Docker 下的 Traefik 上手教程 ::\n星野玲的博客",
    "text": "Docker 下的 Traefik 上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 本来是今天要发布新文章的，但今天正好是大年初一，小玲就顺便祝大家农历新年快乐，万事如意！ 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 Traefik 介绍 # 什么是 Traefik？你如果没听说过 Traefik，那你可能听说过 Nginx、Caddy。Traefik 的功能跟它们差不多，但是用起来比它们更优雅，它可以通过在 docker-compose.yml 文件里写一些 label 完成服务发现。小玲很久以前就用过 Nginx 当反向代理，后来又改为 Caddy，最后因为服务器上的服务都用 Docker 装了，就改用 Traefik 了。 安装 # 安装 Traefik 前，需要先安装 Docker。Docker 的安装方法请看 这里 。因为小玲写这篇文章时 Traefik 3.0 已经发布 Beta 版了，所以咱们采用 Traefik 3.0 版本。 安装完 Docker 后，假设咱们现在在家目录下，咱们新建一个 docker-compose 文件夹用于存放各种服务的 docker-compose.yml 文件。 mkdir -p ~/docker-compose 在 docker-compose 文件夹下创建 traefik 文件夹。 mkdir -p ~/docker-compose/traefik 在 traefik 文件夹下创建 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml 写入以下内容。 version : \"3\" services : traefik : container_name : traefik command : # 启用 Docker 服务提供者，这样 Traefik 就会监听来自 Docker 的配置 - -- providers.docker # 开启一个 8080 端口，并在这个端口上暴露 Traefik API 和一个 web 面板 - -- api.insecure extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 这里的 172.18.0.0/24 网段是 Traefik 和需要与 Traefik 通信的 Docker 容器所在的网段。你也可以改成你喜欢的网段。 172.18.0.1 是 Docker 容器内访问 Docker 容器外的主机的需要连接的 IP 地址。通常是网段的第一个可用地址。 启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 启动后，浏览器访问 http://<你的服务器IP>:8080 ，理论上你就能看到 Traefik 的 web 面板了。 将一个 web 服务暴露在 80 端口上并绑定域名 # 这里咱们就以 whoami 为例，来讲解如何将一个 web 服务暴露在 80 端口上并绑定域名。 在 docker-compose 文件夹下创建 whoami 文件夹。 mkdir -p ~/docker-compose/whoami 在 whoami 文件夹下创建 docker-compose.yml 文件。 vim ~/docker-compose/whoami/docker-compose.yml 写入以下内容。 version : \"3\" services : whoami : image : traefik/whoami labels : # 指定 Traefik 所在的网络为 \"traefik_default\" - traefik.docker.network=traefik_default # 声明一个名为 whoami 的 service # 在名为 whoami 的 service 下，设置端口为容器内的 80 端口 - traefik.http.services.whoami.loadbalancer.server.port=80 # 声明一个名为 whoami 的 route # 在名为 whoami 的 route 下，将 rule 值为 \"Host(`whoami.domain`)\" - traefik.http.routers.whoami.rule=Host(`whoami.domain`) # 在名为 whoami 的 route 下，将 service 设置为 \"whoami\" - traefik.http.routers.whoami.service=whoami networks : # 这个服务需要连接的网络有 traefik_default - traefik_default networks : # 声明这个 docker-compose.yml 里的服务需要使用的网络，这个网络名为 traefik_default traefik_default : # 这个网络是在这个文件外部声明的，所以咱们需要将 external 设为 true external : true Host(`whoami.domain`) 的意思是绑定到域名 whoami.domain 上。 treafik_default 这个名字是怎么来的呢？咱们可以通过 sudo docker network ls 命令查看。 NETWORK ID     NAME              DRIVER    SCOPE 9f0f43903e7a   bridge            bridge    local 4875654d80b2   host              host      local c4fab9dcea28   none              null      local 117f3dd6ec15   traefik_default   bridge    local 启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 想要正常访问 whoami 服务需要做好域名解析，这里咱们就通过改本地的 hosts 文件了，修改方法小玲不再赘述。 通过浏览器访问 whoami.domain 域名，可以看到这时候已经可以访问到 whoami 服务了。 Hostname: de4ebf3ea06e IP: 127.0.0.1 IP: 172.18.0.3 RemoteAddr: 172.18.0.2:49166 GET / HTTP/1.1 Host: whoami.domain User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Dnt: 1 Sec-Gpc: 1 Upgrade-Insecure-Requests: 1 X-Forwarded-For: 192.168.3.16 X-Forwarded-Host: whoami.domain X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: da8861ae460f X-Real-Ip: 192.168.3.16 在 web 面板里也能看到多了一个 route。 通过 Traefik 负载均衡 web 服务 # 为什么说 Traefik 是负载均衡器呢？通过下面这个例子告诉你。 咱们把 whoami 服务扩展到 2 个容器。 sudo docker compose -f ~/docker-compose/whoami/docker-compose.yml up -d --scale whoami = 2 然后不断地刷新 http://whoami.domain ，你就会发现它的 Hostname 和 IP 一直在变化，这就说明 Traefik 已经将请求分摊到了 2 个容器上。而且这个过程咱们只用了 1 条命令，可以说是非常优雅了。 Traefik 与 HTTPS # 现在的 web 服务一般都采用 HTTPS 协议了。所以小玲必须讲如何配置 HTTPS。 首先需要在 Traefik 里定义 2 个 entrypoint，一个名为 web ，绑定在 Traefik 容器的 80 端口上，另一个名为 websecure ，绑定在 Traefik 容器的 443 端口上。 编辑 Traefik 的 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure # 下面未注释的 3 行是新增的内容 # 启用文件服务提供者，并设置配置文件的目录为 \"/etc/traefik/config\" - -- providers.file.directory=/etc/traefik/config # 声明一个名为 web 的 entrypoint，地址为任意地址的 80 端口 - -- entryPoints.web.address=:80 # 声明一个名为 websecure 的 entrypoint，地址为任意地址的 443 端口 - -- entrypoints.websecure.address=:443 extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 # 下面 1 行是新增的内容 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock # 下面 2 行是新增的内容 - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 在家目录下创建 docker_config/traefik 文件夹用于存放 Traefik 的配置文件。 sudo mkdir -p ~/docker_config/traefik 在家目录下创建 docker_data/traefik/certs 文件夹用于存放 Traefik 的证书文件。 sudo mkdir -p ~/docker_data/traefik/certs 重新启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 自定义证书 # 下面用一个例子讲解如何配置自定义证书。假设咱们要将 whoami 服务绑定在 whoami.bling.moe 域名上，并且可以被 HTTP 和 HTTPS 协议同时访问。咱们现在有 *.bling.moe 泛域名证书。 首先要将证书存放在 ~/docker_data/traefik/certs 文件夹下。1 个证书一般有 2 个文件，pem 文件和 key 文件。这里咱们就将 pem 文件命名为 *.bling.moe.pem ，将 key 文件命名为 *.bling.moe.key 。 然后在 ~/docker_config/traefik 文件夹下创建一个 bling.moe.yml 文件，这里的文件名可以随便取。 vim ~/docker_config/traefik/bling.moe.yml 写入以下内容。 tls : certificates : - certFile : /etc/traefik/certs/*.bling.moe.pem keyFile : /etc/traefik/certs/*.bling.moe.key 然后编辑 whoami 的 docker-compose.yml 文件。 vim ~/docker-compose/whoami/docker-compose.yml version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 # 下面未注释的 1 行与原来不同 # 在名为 whoami 的 route 下，将 rule 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami # 下面未注释的 5 行是新增的内容 # 在名为 whoami 的 route 下，将 entrypoint 设置为 \"web\" - traefik.http.routers.whoami.entrypoints=web # 声明一个名为 whoami-secured 的 route # 在名为 whoami-secured 的 route 下，将 rule 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) # 在名为 whoami-secured 的 route 下，将 service 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami-secured.service=whoami # 在名为 whoami-secured 的 route 下，将 tls 设置 true - traefik.http.routers.whoami-secured.tls # 在名为 whoami-secured 的 route 下，将 entrypoint 设置为 websecure - traefik.http.routers.whoami-secured.entrypoints=websecure networks : - traefik_default networks : traefik_default : external : true 重新启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 使用浏览器访问 http://whoami.bling.moe 和 https://whoami.bling.moe ，你会发现都可以访问了。 使用 Let’s Encrypt 的证书 # Traefik 内置了获取 Let’s Encrypt 的证书的功能。在使用这个功能之前咱们需要先在 Traefik 的设置里新增一个 certificatesresolver。 编辑 Traefik 的 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 # 下面未注释的 2 行是新增的内容 # 声明一个名为 myresolver 的 certificatesresolver # 在名为 myresolver 的 certificatesresolver 下，将 httpchallenge 的 entrypoint 设置为 \"web\" - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web # 在名为 myresolver 的 certificatesresolver 下，将 storage 设置为 \"/etc/traefik/certs/acme.json\" - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 重新启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 如果以前有使用自定义证书，则需要把自定义证书的配置删除。这里小玲就将 yml 文件加上 .bak 后缀，让 Traefik 不把它当成一个配置文件。 mv ~/docker_config/traefik/bling.moe.yml ~/docker_config/traefik/bling.moe.yml.bak 然后编辑 whoami 的 docker-compose.yml 文件。 vim ~/docker compose/whoami/docker-compose.yml version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure # 下面未注释的 1 行是新增的内容 # 在名为 whoami-secured 的 route 下，将 certresolver 设置为 myresolver - traefik.http.routers.whoami-secured.tls.certresolver=myresolver networks : - traefik_default networks : traefik_default : external : true 重新启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 使用浏览器访问 https://whoami.bling.moe ，你会发现已经在使用 Let’s Encrypt 的证书了。 ~/docker_data/traefik/certs 文件夹下也有一个 acme.json 文件，里面有 Let’s Encrypt 的证书数据。 结尾 # 好了，有了以上的知识，你应该可以开始上手 Traefik 了。还有一些进阶的知识因为小玲在写这篇文章的时候比较赶，所以只能留到下次再写一篇文章了。你也可以通过查看 Traefik 的 文档 来学习更多使用方法。 阅读其它文章 ← Docker 下的 Traefik 上手教程（二） 使用 Kotlin 语言实现一个归并排序算法 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker/",
    "title": "Docker ::\n星野玲的博客",
    "text": "Docker ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker-compose/",
    "title": "Docker Compose ::\n星野玲的博客",
    "text": "Docker Compose ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/traefik/",
    "title": "Traefik ::\n星野玲的博客",
    "text": "Traefik ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/14/",
    "title": "Docker 下的 Traefik 上手教程 ::\n星野玲的博客",
    "text": "Docker 下的 Traefik 上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 本来是今天要发布新文章的，但今天正好是大年初一，小玲就顺便祝大家农历新年快乐，万事如意！ 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 Traefik 介绍 # 什么是 Traefik？你如果没听说过 Traefik，那你可能听说过 Nginx、Caddy。Traefik 的功能跟它们差不多，但是用起来比它们更优雅，它可以通过在 docker-compose.yml 文件里写一些 label 完成服务发现。小玲很久以前就用过 Nginx 当反向代理，后来又改为 Caddy，最后因为服务器上的服务都用 Docker 装了，就改用 Traefik 了。 安装 # 安装 Traefik 前，需要先安装 Docker。Docker 的安装方法请看 这里 。因为小玲写这篇文章时 Traefik 3.0 已经发布 Beta 版了，所以咱们采用 Traefik 3.0 版本。 安装完 Docker 后，假设咱们现在在家目录下，咱们新建一个 docker-compose 文件夹用于存放各种服务的 docker-compose.yml 文件。 mkdir -p ~/docker-compose 在 docker-compose 文件夹下创建 traefik 文件夹。 mkdir -p ~/docker-compose/traefik 在 traefik 文件夹下创建 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml 写入以下内容。 version : \"3\" services : traefik : container_name : traefik command : # 启用 Docker 服务提供者，这样 Traefik 就会监听来自 Docker 的配置 - -- providers.docker # 开启一个 8080 端口，并在这个端口上暴露 Traefik API 和一个 web 面板 - -- api.insecure extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 这里的 172.18.0.0/24 网段是 Traefik 和需要与 Traefik 通信的 Docker 容器所在的网段。你也可以改成你喜欢的网段。 172.18.0.1 是 Docker 容器内访问 Docker 容器外的主机的需要连接的 IP 地址。通常是网段的第一个可用地址。 启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 启动后，浏览器访问 http://<你的服务器IP>:8080 ，理论上你就能看到 Traefik 的 web 面板了。 将一个 web 服务暴露在 80 端口上并绑定域名 # 这里咱们就以 whoami 为例，来讲解如何将一个 web 服务暴露在 80 端口上并绑定域名。 在 docker-compose 文件夹下创建 whoami 文件夹。 mkdir -p ~/docker-compose/whoami 在 whoami 文件夹下创建 docker-compose.yml 文件。 vim ~/docker-compose/whoami/docker-compose.yml 写入以下内容。 version : \"3\" services : whoami : image : traefik/whoami labels : # 指定 Traefik 所在的网络为 \"traefik_default\" - traefik.docker.network=traefik_default # 声明一个名为 whoami 的 service # 在名为 whoami 的 service 下，设置端口为容器内的 80 端口 - traefik.http.services.whoami.loadbalancer.server.port=80 # 声明一个名为 whoami 的 route # 在名为 whoami 的 route 下，将 rule 值为 \"Host(`whoami.domain`)\" - traefik.http.routers.whoami.rule=Host(`whoami.domain`) # 在名为 whoami 的 route 下，将 service 设置为 \"whoami\" - traefik.http.routers.whoami.service=whoami networks : # 这个服务需要连接的网络有 traefik_default - traefik_default networks : # 声明这个 docker-compose.yml 里的服务需要使用的网络，这个网络名为 traefik_default traefik_default : # 这个网络是在这个文件外部声明的，所以咱们需要将 external 设为 true external : true Host(`whoami.domain`) 的意思是绑定到域名 whoami.domain 上。 treafik_default 这个名字是怎么来的呢？咱们可以通过 sudo docker network ls 命令查看。 NETWORK ID     NAME              DRIVER    SCOPE 9f0f43903e7a   bridge            bridge    local 4875654d80b2   host              host      local c4fab9dcea28   none              null      local 117f3dd6ec15   traefik_default   bridge    local 启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 想要正常访问 whoami 服务需要做好域名解析，这里咱们就通过改本地的 hosts 文件了，修改方法小玲不再赘述。 通过浏览器访问 whoami.domain 域名，可以看到这时候已经可以访问到 whoami 服务了。 Hostname: de4ebf3ea06e IP: 127.0.0.1 IP: 172.18.0.3 RemoteAddr: 172.18.0.2:49166 GET / HTTP/1.1 Host: whoami.domain User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/109.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,en-US;q=0.7,en;q=0.3 Dnt: 1 Sec-Gpc: 1 Upgrade-Insecure-Requests: 1 X-Forwarded-For: 192.168.3.16 X-Forwarded-Host: whoami.domain X-Forwarded-Port: 80 X-Forwarded-Proto: http X-Forwarded-Server: da8861ae460f X-Real-Ip: 192.168.3.16 在 web 面板里也能看到多了一个 route。 通过 Traefik 负载均衡 web 服务 # 为什么说 Traefik 是负载均衡器呢？通过下面这个例子告诉你。 咱们把 whoami 服务扩展到 2 个容器。 sudo docker compose -f ~/docker-compose/whoami/docker-compose.yml up -d --scale whoami = 2 然后不断地刷新 http://whoami.domain ，你就会发现它的 Hostname 和 IP 一直在变化，这就说明 Traefik 已经将请求分摊到了 2 个容器上。而且这个过程咱们只用了 1 条命令，可以说是非常优雅了。 Traefik 与 HTTPS # 现在的 web 服务一般都采用 HTTPS 协议了。所以小玲必须讲如何配置 HTTPS。 首先需要在 Traefik 里定义 2 个 entrypoint，一个名为 web ，绑定在 Traefik 容器的 80 端口上，另一个名为 websecure ，绑定在 Traefik 容器的 443 端口上。 编辑 Traefik 的 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure # 下面未注释的 3 行是新增的内容 # 启用文件服务提供者，并设置配置文件的目录为 \"/etc/traefik/config\" - -- providers.file.directory=/etc/traefik/config # 声明一个名为 web 的 entrypoint，地址为任意地址的 80 端口 - -- entryPoints.web.address=:80 # 声明一个名为 websecure 的 entrypoint，地址为任意地址的 443 端口 - -- entrypoints.websecure.address=:443 extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 # 下面 1 行是新增的内容 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock # 下面 2 行是新增的内容 - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 在家目录下创建 docker_config/traefik 文件夹用于存放 Traefik 的配置文件。 sudo mkdir -p ~/docker_config/traefik 在家目录下创建 docker_data/traefik/certs 文件夹用于存放 Traefik 的证书文件。 sudo mkdir -p ~/docker_data/traefik/certs 重新启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 自定义证书 # 下面用一个例子讲解如何配置自定义证书。假设咱们要将 whoami 服务绑定在 whoami.bling.moe 域名上，并且可以被 HTTP 和 HTTPS 协议同时访问。咱们现在有 *.bling.moe 泛域名证书。 首先要将证书存放在 ~/docker_data/traefik/certs 文件夹下。1 个证书一般有 2 个文件，pem 文件和 key 文件。这里咱们就将 pem 文件命名为 *.bling.moe.pem ，将 key 文件命名为 *.bling.moe.key 。 然后在 ~/docker_config/traefik 文件夹下创建一个 bling.moe.yml 文件，这里的文件名可以随便取。 vim ~/docker_config/traefik/bling.moe.yml 写入以下内容。 tls : certificates : - certFile : /etc/traefik/certs/*.bling.moe.pem keyFile : /etc/traefik/certs/*.bling.moe.key 然后编辑 whoami 的 docker-compose.yml 文件。 vim ~/docker-compose/whoami/docker-compose.yml version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 # 下面未注释的 1 行与原来不同 # 在名为 whoami 的 route 下，将 rule 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami # 下面未注释的 5 行是新增的内容 # 在名为 whoami 的 route 下，将 entrypoint 设置为 \"web\" - traefik.http.routers.whoami.entrypoints=web # 声明一个名为 whoami-secured 的 route # 在名为 whoami-secured 的 route 下，将 rule 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) # 在名为 whoami-secured 的 route 下，将 service 设置为 \"Host(`whoami.bling.moe`)\" - traefik.http.routers.whoami-secured.service=whoami # 在名为 whoami-secured 的 route 下，将 tls 设置 true - traefik.http.routers.whoami-secured.tls # 在名为 whoami-secured 的 route 下，将 entrypoint 设置为 websecure - traefik.http.routers.whoami-secured.entrypoints=websecure networks : - traefik_default networks : traefik_default : external : true 重新启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 使用浏览器访问 http://whoami.bling.moe 和 https://whoami.bling.moe ，你会发现都可以访问了。 使用 Let’s Encrypt 的证书 # Traefik 内置了获取 Let’s Encrypt 的证书的功能。在使用这个功能之前咱们需要先在 Traefik 的设置里新增一个 certificatesresolver。 编辑 Traefik 的 docker-compose.yml 文件。 vim ~/docker-compose/traefik/docker-compose.yml version : \"3\" services : traefik : container_name : traefik command : - -- providers.docker - -- api.insecure - -- providers.file.directory=/etc/traefik/config - -- entryPoints.web.address=:80 - -- entrypoints.websecure.address=:443 # 下面未注释的 2 行是新增的内容 # 声明一个名为 myresolver 的 certificatesresolver # 在名为 myresolver 的 certificatesresolver 下，将 httpchallenge 的 entrypoint 设置为 \"web\" - -- certificatesresolvers.myresolver.acme.httpchallenge.entrypoint=web # 在名为 myresolver 的 certificatesresolver 下，将 storage 设置为 \"/etc/traefik/certs/acme.json\" - -- certificatesresolvers.myresolver.acme.storage=/etc/traefik/certs/acme.json extra_hosts : \"host.docker.internal\": \"172.18.0.1\" image : traefik:v3.0 ports : - 80 : 80 - 443 : 443 - 8080 : 8080 restart : unless-stopped volumes : - /var/run/docker.sock:/var/run/docker.sock - ../../docker_config/traefik:/etc/traefik/config - ../../docker_data/traefik/certs:/etc/traefik/certs networks : default : driver : bridge ipam : driver : default config : - subnet : \"172.18.0.0/24\" 重新启动 Traefik。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 如果以前有使用自定义证书，则需要把自定义证书的配置删除。这里小玲就将 yml 文件加上 .bak 后缀，让 Traefik 不把它当成一个配置文件。 mv ~/docker_config/traefik/bling.moe.yml ~/docker_config/traefik/bling.moe.yml.bak 然后编辑 whoami 的 docker-compose.yml 文件。 vim ~/docker compose/whoami/docker-compose.yml version : \"3\" services : whoami : image : traefik/whoami labels : - traefik.docker.network=traefik_default - traefik.http.services.whoami.loadbalancer.server.port=80 - traefik.http.routers.whoami.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami.service=whoami - traefik.http.routers.whoami.entrypoints=web - traefik.http.routers.whoami-secured.rule=Host(`whoami.bling.moe`) - traefik.http.routers.whoami-secured.service=whoami - traefik.http.routers.whoami-secured.tls - traefik.http.routers.whoami-secured.entrypoints=websecure # 下面未注释的 1 行是新增的内容 # 在名为 whoami-secured 的 route 下，将 certresolver 设置为 myresolver - traefik.http.routers.whoami-secured.tls.certresolver=myresolver networks : - traefik_default networks : traefik_default : external : true 重新启动 whoami 。 sudo docker compose -f ~/docker-compose/traefik/docker-compose.yml up -d 使用浏览器访问 https://whoami.bling.moe ，你会发现已经在使用 Let’s Encrypt 的证书了。 ~/docker_data/traefik/certs 文件夹下也有一个 acme.json 文件，里面有 Let’s Encrypt 的证书数据。 结尾 # 好了，有了以上的知识，你应该可以开始上手 Traefik 了。还有一些进阶的知识因为小玲在写这篇文章的时候比较赶，所以只能留到下次再写一篇文章了。你也可以通过查看 Traefik 的 文档 来学习更多使用方法。 阅读其它文章 ← Docker 下的 Traefik 上手教程（二） 使用 Kotlin 语言实现一个归并排序算法 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/13/",
    "title": "使用 Kotlin 语言实现一个归并排序算法 ::\n星野玲的博客",
    "text": "使用 Kotlin 语言实现一个归并排序算法 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来讲归并排序算法的实现。但是从这次开始不再讲 IDE 的安装和创建项目了。需要的话请看 这里 。 开始编写 # 这里从创建好了项目开始。首先写出归并排序函数的大概框架。它的函数名为 mergeSort ，接收一个类型为 List<Double> 、名称为 list 的形参，返回值类型为 List<Double> 。注意它的返回值永远都是已经排好序的 List 。 fun mergeSort (list: List<Double>): List<Double> { } 归并排序算法和快速排序算法一样是采用递归加分治的方法来写的。判断小于或等于 1 的原因和快速排序算法一样，小玲就不再赘述了。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { } } if 语句的 else 块里就像写快速排序算法一样写递归和分治的代码。 首先咱们需要把这个长度大于 1 的 list，从中间分成两个部分—— leftList 和 rightList 。 如果这个长度大于 1 的 list 的长度是偶数， leftList 和 rightList 的长度就是相等的。 如果这个长度大于 1 的 list 的长度是奇数， leftList 将比 rightList 多一个元素。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) } } 然后分别对 leftList 和 rightList 递归调用这个函数本身。调用后的返回值分别赋给 sortedLeftList 和 sortedRightLeft 。因为 mergeSort 函数的返回值永远都是已经排好序的 List 。所以现在咱们默认 sortedLeftList 和 sortedRightList 是已经排好序的 List 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) } } 现在咱们来编写将两个已经排好序的 list 合并成一个已经排好序的 list 的代码。 定义一个可变的 list 并将它赋值给变量 sortedList 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() } } 定义变量 tempIndexInSortedLeftList 和 tempIndexInSortedRightList ，并将它们的初始值设为 0，这两个变量是用于接下来的 while 循环的。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 } } 接下来咱们写一个 while 循环来遍历 sortedLeftList 和 sortedRightList 。这个 while 循环的作用是把 sortedLeftList 和 sortedRightList 合并成一个已经排好序的 list—— sortedList 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } } } 最后，返回 sortedList 。到此为止，咱们的函数就写完啦。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } sortedList } } 测试 # 写完了以后，咱们来测试一下吧。 下面是最终的 Main.kt 文件。 import kotlin.math.roundToInt import kotlin.random.Random import kotlin.system.getTimeMillis fun main () { val list = mutableListOf<Double>() val random = Random(getTimeMillis()) for (i in 0. . 9 ) { list.add((random.nextDouble( 1.0 , 100.0 ) * 10 ).roundToInt() / 10.0 ) } println( \"Original list is $list \" ) println( \"Sorted list from mergeSort is ${mergeSort(list)} \" ) } fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } sortedList } } 执行结果，很完美地从小到大排序了。 Original list is [ 4.9 , 91.0 , 41.9 , 34.5 , 49.5 , 16.6 , 9.7 , 93.5 , 84.9 , 63.3 ] Sorted list from mergeSort is [ 4.9 , 9.7 , 16.6 , 34.5 , 41.9 , 49.5 , 63.3 , 84.9 , 91.0 , 93.5 ] 阅读其它文章 ← Docker 下的 Traefik 上手教程 使用 Kotlin 语言实现一个快速排序算法 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/kotlin/",
    "title": "Kotlin ::\n星野玲的博客",
    "text": "Kotlin ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E7%AE%97%E6%B3%95/",
    "title": "算法 ::\n星野玲的博客",
    "text": "算法 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/13/",
    "title": "使用 Kotlin 语言实现一个归并排序算法 ::\n星野玲的博客",
    "text": "使用 Kotlin 语言实现一个归并排序算法 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来讲归并排序算法的实现。但是从这次开始不再讲 IDE 的安装和创建项目了。需要的话请看 这里 。 开始编写 # 这里从创建好了项目开始。首先写出归并排序函数的大概框架。它的函数名为 mergeSort ，接收一个类型为 List<Double> 、名称为 list 的形参，返回值类型为 List<Double> 。注意它的返回值永远都是已经排好序的 List 。 fun mergeSort (list: List<Double>): List<Double> { } 归并排序算法和快速排序算法一样是采用递归加分治的方法来写的。判断小于或等于 1 的原因和快速排序算法一样，小玲就不再赘述了。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { } } if 语句的 else 块里就像写快速排序算法一样写递归和分治的代码。 首先咱们需要把这个长度大于 1 的 list，从中间分成两个部分—— leftList 和 rightList 。 如果这个长度大于 1 的 list 的长度是偶数， leftList 和 rightList 的长度就是相等的。 如果这个长度大于 1 的 list 的长度是奇数， leftList 将比 rightList 多一个元素。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) } } 然后分别对 leftList 和 rightList 递归调用这个函数本身。调用后的返回值分别赋给 sortedLeftList 和 sortedRightLeft 。因为 mergeSort 函数的返回值永远都是已经排好序的 List 。所以现在咱们默认 sortedLeftList 和 sortedRightList 是已经排好序的 List 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) } } 现在咱们来编写将两个已经排好序的 list 合并成一个已经排好序的 list 的代码。 定义一个可变的 list 并将它赋值给变量 sortedList 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() } } 定义变量 tempIndexInSortedLeftList 和 tempIndexInSortedRightList ，并将它们的初始值设为 0，这两个变量是用于接下来的 while 循环的。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 } } 接下来咱们写一个 while 循环来遍历 sortedLeftList 和 sortedRightList 。这个 while 循环的作用是把 sortedLeftList 和 sortedRightList 合并成一个已经排好序的 list—— sortedList 。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } } } 最后，返回 sortedList 。到此为止，咱们的函数就写完啦。 fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } sortedList } } 测试 # 写完了以后，咱们来测试一下吧。 下面是最终的 Main.kt 文件。 import kotlin.math.roundToInt import kotlin.random.Random import kotlin.system.getTimeMillis fun main () { val list = mutableListOf<Double>() val random = Random(getTimeMillis()) for (i in 0. . 9 ) { list.add((random.nextDouble( 1.0 , 100.0 ) * 10 ).roundToInt() / 10.0 ) } println( \"Original list is $list \" ) println( \"Sorted list from mergeSort is ${mergeSort(list)} \" ) } fun mergeSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val middleIndex = if (list.size % 2 == 0 ) list.size / 2 else list.size / 2 + 1 val leftList = list.subList( 0 , middleIndex) val rightList = list.subList(middleIndex, list.size) val sortedLeftList = mergeSort(leftList) val sortedRightList = mergeSort(rightList) val sortedList = mutableListOf<Double>() var tempIndexInSortedLeftList = 0 var tempIndexInSortedRightList = 0 while (tempIndexInSortedLeftList < sortedLeftList.size || tempIndexInSortedRightList < sortedRightList.size) { if (tempIndexInSortedLeftList == sortedLeftList.size) { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } else if (tempIndexInSortedRightList == sortedRightList.size){ sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else if (sortedLeftList[tempIndexInSortedLeftList] < sortedRightList[tempIndexInSortedRightList]) { sortedList.add(sortedLeftList[tempIndexInSortedLeftList ++ ]) } else { sortedList.add(sortedRightList[tempIndexInSortedRightList ++ ]) } } sortedList } } 执行结果，很完美地从小到大排序了。 Original list is [ 4.9 , 91.0 , 41.9 , 34.5 , 49.5 , 16.6 , 9.7 , 93.5 , 84.9 , 63.3 ] Sorted list from mergeSort is [ 4.9 , 9.7 , 16.6 , 34.5 , 41.9 , 49.5 , 63.3 , 84.9 , 91.0 , 93.5 ] 阅读其它文章 ← Docker 下的 Traefik 上手教程 使用 Kotlin 语言实现一个快速排序算法 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/12/",
    "title": "使用 Kotlin 语言实现一个快速排序算法 ::\n星野玲的博客",
    "text": "使用 Kotlin 语言实现一个快速排序算法 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。快速排序算法的原理小玲就不再赘述了，这里小玲只讲实现。 安装 Intellij IDEA # 咱们要采用 Intellij IDEA 这款 IDE 来编写 Kotlin 程序。如果你已经有了可以跳过。 因为目前小玲还在使用 Windows，所以给出的安装命令都是 Windows 的。如果你使用 macOS、Linux，还请自己学习如何安装。 这是使用 Scoop 安装 Intellij IDEA 的命令。 scoop bucket add extras scoop install extras/idea 开发 Kotlin Native 程序还是需要一个 JDK 的。如果你没有 JDK，可以安装一个。小玲就用 graalvm-17 这个 JDK 好了。 scoop bucket add java scoop install java/graalvm-jdk17 创建项目 # 因为咱们只使用 Kotlin 语言，所以要创建一个 Kotlin Native 项目。Kotlin Native 项目要在 Kotlin Multiplatform 里面创建。 这一步咱们不需要修改，直接点击 Finish 即可。 开始编写 # 创建完成后， src/nativeMain/kotlin/Main.kt 文件默认如下。 fun main () { println( \"Hello, Kotlin/Native!\" ) } 咱们在 main() 函数的下面写上快速排序函数的大概框架。首先它的函数名为 quickSort ，接收一个类型为 List<Double> 、名称为 list 的形参，返回值类型为 List<Double> 。 fun quickSort (list: List<Double>): List<Double> { } 咱们采用递归加分治的方法来写。因为是递归了，所以一定要有一个递归出口，否则会无限循环。 这里咱们就判断形参 list 有多少个元素，如果元素个数小于或等于 1 了，就直接返回这个形参。这也适用于用 quickSort() 函数处理只有一个元素的 List 的情况。因为只有 1 个元素了，所以就没有排序的必要了，直接返回它本身就好。 fun quickSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { } } if 语句的 else 块里就要写递归和分治的代码了。 咱们需要在这个 List 里先找一个基准点。把 List 里除了基准点所在的元素的剩余所有元素划分为两个部分。 一个部分里的所有元素都比基准点所在的元素小，这个部分咱们称作 leftList ，意思是从小到大排序的话，这个部分都会在基准点左边。 另一个部分里的所有元素都比基准点所在的元素大或等于基准点所在的元素，这个部分咱们称作 rightList ，意思是从小到大排序的话，这个部分都会在基准点的右边。 然后对 leftList 和 rightList 递归调用这个函数本身，它会不断地划分 leftList 的 leftList 、 leftList 的 rightList 、 rightList 的 leftList 、 rightList 的 rightList ，直到不可划分为止。再按 leftList 、基准点、 rightList 的顺序合并 List，把合并的结果返回给上一层，直到不可合并为止。最后合并这个结果就是整个 list 形参排序之后的结果了。 下面是代码实现，现在咱们就写完 quickSort() 函数了。现在这个函数除了注释就只有 11 行。 fun quickSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { // 定义基准点位于 list 中的索引 val pivotIndex = 0 // 将 list 中除了基准点的剩余元素找出来，并存放在 listWithoutPivot 变量里。 val listWithoutPivot = list.filterIndexed{ it , _ -> it != pivotIndex} // 将 listWithoutPivot 里小于基准点的元素找出来，并存放在 leftList 变量里。 val leftList = listWithoutPivot.filter { it < list[pivotIndex] } // 将 listWithoutPivot 里大于或等于基准点的元素找出来，并存放在 rightList 变量里。 val rightList = listWithoutPivot.filter { it >= list[pivotIndex] } // 递归调用和合并 listOf(quickSort(leftList), listOf(list[pivotIndex]), quickSort(rightList)).flatten() } } 至于将哪个元素作为基准点其实都可以，它不会影响最终排序的结果。这里咱们就将 list 里的第 1 个元素作为基准点，你也可以将 list 的最后一个元素作为基准点。 val pivotIndex = list.size - 1 也可以将中间那个元素作为基准点。 val pivotIndex = if (list.size % 2 == 0 ) list.size / 2 - 1 else list.size / 2 不过要注意索引不要溢出，比如 list 里只有 2 个元素，取第 3 个元素作为基准点就溢出了。 测试 # 写完了以后，咱们来测试一下吧。把 main() 函数修改一下。生成 10 个小数点后有 1 位的小数，再把它们添加到一个 List 里，然后对这个 List 进行排序，观察排序的结果。 下面是最终的 Main.kt 文件。 import kotlin.math.roundToInt import kotlin.random.Random import kotlin.system.getTimeMillis fun main () { val list = mutableListOf<Double>() val random = Random(getTimeMillis()) for (i in 0. . 9 ) { list.add((random.nextDouble( 1.0 , 100.0 ) * 10 ).roundToInt() / 10.0 ) } println( \"Original list is $list \" ) println( \"Sorted list from quickSort is ${quickSort(list)} \" ) } fun quickSort (list: List<Double>): List<Double> { return if (list.size <= 1 ) { list } else { val pivotIndex = 0 val listWithoutPivot = list.filterIndexed{ it , _ -> it != pivotIndex} val leftList = listWithoutPivot.filter { it < list[pivotIndex] } val rightList = listWithoutPivot.filter { it >= list[pivotIndex] } listOf(quickSort(leftList), listOf(list[pivotIndex]), quickSort(rightList)).flatten() } } 执行结果，很完美地从小到大排序了。 Original list is [64.8, 74.6, 96.7, 57.1, 58.3, 59.4, 18.8, 60.2, 4.9, 17.4] Sorted list from quickSort is [4.9, 17.4, 18.8, 57.1, 58.3, 59.4, 60.2, 64.8, 74.6, 96.7] 结尾 # 好了，这篇文章就到这里。这是小玲首次写编程相关的文章。可能会有一些错误，如果有，还请指正，谢谢！ 阅读其它文章 ← 使用 Kotlin 语言实现一个归并排序算法 Windows 包管理器——Scoop 上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/kotlin/",
    "title": "Kotlin ::\n星野玲的博客",
    "text": "Kotlin ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E7%AE%97%E6%B3%95/",
    "title": "算法 ::\n星野玲的博客",
    "text": "算法 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Kotlin 语言实现一个归并排序算法 2023-01-15 — 作者： 星野玲 #Kotlin #算法 上周小玲讲了快速排序算法。这周小玲来将归并排序算法的实现。 阅读更多 → 使用 Kotlin 语言实现一个快速排序算法 2023-01-08 — 作者： 星野玲 #Kotlin #算法 今天小玲来教大家用 Kotlin 语言实现一个快速排序算法。将一个元素是 Double 类型的 List 从小到大排序。整个函数代码仅仅只有 11 行。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/11/",
    "title": "Windows 包管理器——Scoop 上手教程 ::\n星野玲的博客",
    "text": "Windows 包管理器——Scoop 上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——Scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 安装 Scoop # 安装前请确保已经安装了 Powershell 5.1 或更新的版本。现在的 Windows 10 在安装完系统后都已经自带了上面这两个了。所以使用 Windows 10 的你一般情况下不用特地去再安装了。 第一次安装时，咱们先要指定 Scoop 的安装路径，因为这个路径还决定了使用 Scoop 安装的软件的安装路径，所以请务必考虑好安装在哪。小玲的建议是不要安装在 C 盘，这样如果你重装系统后，你使用 Scoop 安装的软件就不会被删除，可以很快地把软件恢复回来而不用再一个一个下载。下面的 Scoop 变量的值 D:\\Users\\DemoUser\\Scoop 和 SCOOP_GLOBAL 变量的值 D:\\Scoop 是小玲为了演示使用的路径。请根据你的实际情况修改为适合你的值。 SCOOP 变量的值是 Scoop 在当前用户安装的位置。 SCOOP_GLOBAL 变量的值是是 Scoop 在全局安装的位置。 [ Environment ]::SetEnvironmentVariable( 'SCOOP' , 'D:\\Users\\DemoUser\\Scoop' , 'User' ); [ Environment ]::SetEnvironmentVariable( 'SCOOP_GLOBAL' , 'D:\\Scoop' , 'Machine' ); Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser; irm get.scoop.sh | iex 启动 Powershell，把上面的命令一行行地复制进终端执行就可以安装 Scoop 了。注意 [Environment]::SetEnvironmentVariable('SCOOP_GLOBAL', 'D:\\Scoop', 'Machine'); 这条命令需要管理员权限。所以你需要打开有管理员权限的 Powershell 才能执行这条命令。 开始使用 # Git 是每个使用 Scoop 的人必须装的 app，有了 Git，咱们才能添加 bucket。所以安装完 Scoop 的第一件事就是安装 Git。 scoop install git Bucket # bucket 是一个 app 元数据的集合，一个 bucket 存放在 Git 仓库里。安装完 Scoop 后默认只有 main Bucket。 下面是 Scoop 社区维护的 bucket。 你可以通过 scoop bucket known 查看这个列表。 通过 scoop bucket list 查看已添加的 bucket。 通过 scoop bucket add <bucket> 添加 bucket。 通过 scoop bucket rm <bucket> 移除 bucket。 bucket 添加命令 移除命令 main scoop bucket add main scoop bucket rm main extras scoop bucket add extras scoop bucket rm extras versions scoop bucket add versions scoop bucket rm versions nirsoft scoop bucket add nirsoft scoop bucket rm nirsoft sysinternals scoop bucket add sysinternals scoop bucket rm sysinternals php scoop bucket add php scoop bucket rm php nerd-fonts scoop bucket add nerd-fonts scoop bucket rm nerd-fonts nonportable scoop bucket add nonportable scoop bucket rm nonportable java scoop bucket add java scoop bucket rm java games scoop bucket add games scoop bucket rm games Scoop 社区就规定 main bucket 存放着开发者会用到的 app，比如某种语言的开发环境。还有一些知名的 CLI 程序。它的最大特点就是没有 GUI。（当然 7zip 是个例外。） 1 Extras bucket 存放着不符合 main bucket 规定但又知名的程序。比如浏览器这种 GUI 程序，你都可以在 extras bucket 里找到。 Versions bucket 存放着一些知名的 app 的旧版本。 Php bucket 存放着从远古版本到最新版本的 PHP。 Nerd-fonts bucket 存放着 Nerd 字体和其他字体。 Nonportable 存放着非便携软件。也就是重装系统后虽然文件还在硬盘上，但已经不能正常运行的软件。比如通常的第三方输入法就是非便携软件。小玲不建议大家通过 Scoop 安装非便携软件。如果你的 Scoop 是安装在非 C 盘上的，重装系统后通过 Scoop 安装的非便携软件的文件虽然还残留在硬盘上，但已经不能正常使用了，这时你需要先通过 Scoop 卸载再安装才能使用。对于非便携软件，小玲建议通过 winget 安装。 Java bucket 存放着不同版本的 JRE 和 JDK。 Games bucket 存放着开源游戏和免费游戏。 一般来说 main 仓库和 extras 仓库是每个人必备的仓库。 注意事项 # 如果你在没装 Git 的情况下通过 scoop bucket rm main 把 main bucket 移除了。这时候你就会发现你因为没有 Git，无法通过 scoop bucket add main 添加 main bucket，而且因为没有 main bucket，无法通过 scoop install git 安装 Git。这时候貌似陷入了一个死循环。不过好在 Scoop 可以通过 scoop install <mainfest_url> 的方式安装一个 app 。所以咱们只需通过 scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/git.json 就可以安装 Git 啦。 安装 app # 添加完 bucket 后就可以安装 app 了，咱们可以通过 scoop install 命令来安装 app，命令格式如下。 scoop install [<bucket_name>/]<app_name>[@<version>] scoop install <manifest_url> 例如，安装 Chrome。 scoop bucket add extras scoop install googlechrome 但是假如有两个 bucket 都有 googlechrome 这个 app。那通过 scoop install googlechrome 安装的是哪个 bucket 的 googlechrome 呢？ 咱们可以通过 scoop search 命令来搜索 app，遇到不同 bucket 里有同名的 app 时一般会安装搜索结果里最靠前的那个 bucket 的 app。 如果要指定安装某个 bucket 的 app 就需要这样子写。 scoop install extras/googlechrome 如果要安装指定版本的 app 就需要这样子写。 scoop install extras/googlechrome@107.0.5304.107 小玲也建议大家平常安装 app 时，先搜索一下 app 的名字，如果有两个或以上的 bucket 都有同名的 app 时，通过上面的方法精确定位你要安装的 app。 如果想为所有用户安装，就要使用 -g 参数来进行全局安装，卸载时也是如此。 搜索 app # scoop search <app_name> 不过 Scoop 自带的搜索命令在 bucket 数量多时会比较慢，小玲建议大家安装 scoop-search 这个包。 scoop install main/scoop-search 通过 scoop-search 命令来搜索会比 scoop search 快很多。 scoop-search <app_name> 卸载 app # scoop uninstall <app_name> 一些 app 会产生能被 Scoop 管理的数据，如果你想在卸载 app 时同时删除这些数据，请加入 -p 参数。 查看已安装的 APP # scoop list 更新 Scoop # scoop update 这个命令可以更新 Scoop 和 bucket 的元数据。 更新 app # scoop update <app_name> 如果要更新所有 app，可以使用 scoop update * 或 scoop update -a 。 禁止更新 app # 如果你希望一直使用某个 app 的旧版本，不希望在使用 scoop update -a 时将它升级到最新版，可以使用这个命令禁止更新这个 app。 scoop hold <app_name> 解除禁止更新可以用这个命令。 scoop unhold <app_name> 清理旧版本 # scoop cleanup <app_name> Scoop 在安装 app 的新版本时，不会删除旧版本。所以咱们需要用这个命令来清理旧版本。 清理安装文件 # Scoop 在安装 app 时，会保留安装文件。 你可以通过 scoop cache 查看所有安装文件。 通过 scoop cache rm <app_name> 删除指定 app 的安装文件。 通过 scoop cache rm * 或 scoop cache rm -a 或 scoop cache rm --all 删除所有安装文件。 设置 Scoop # 你可以通过 scoop help config 来查看 Scoop 都有哪些设置。 通过 scoop config 查看所有已修改的设置。 通过 scoop config <config_name> 查看设置的值。 通过 scoop config <config_name> <value> 更新设置。 通过 scoop config rm <config_name> 删除设置。 给 Scoop 设置代理 # 如果在使用 Scoop 时遇到下载慢的问题，可以给 Scoop 设置一个代理。这个代理得是 HTTP 代理，SOCKS 代理是不行的。 scoop config proxy [<username> : <password>@]host : port 使用 Aria2 多线程下载 # 你可以使用 Aria2 多线程下载。不过并不是什么 app 都支持多线程下载的。有时候会有下载失败的情况。小玲的建议是开启代理就行了，如果代理的速度够快，就没有必要使用多线程下载。 安装 Aria2。 scoop install main/aria2 让 Scoop 使用 aria2 scoop config aria2-enabled true 让 Scoop 不使用 aria2 scoop config aria2-enabled false 重装系统后恢复 Scoop # 重装系统后，只需重新设置一下环境变量，不需要重新下载 Scoop。注意下面的路径要设置成你原来的路径。 [ Environment ]::SetEnvironmentVariable( 'SCOOP' , 'D:\\Users\\DemoUser\\Scoop' , 'User' ) [ Environment ]::SetEnvironmentVariable( 'SCOOP_GLOBAL' , 'D:\\Scoop' , 'Machine' ) [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; \" + [ Environment ]::GetEnvironmentVariable( 'SCOOP' , 'User' ) + \"\\shims\" , 'User' ) # 注意下面的命令需要管理员权限。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'Machine' ) + \"; \" + [ Environment ]::GetEnvironmentVariable( 'SCOOP_GLOBAL' , 'Machine' ) + \"\\shims\" , 'Machine' ) Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 恢复所有 Scoop 安装的软件。 scoop reset * 然后你就会发现，原来使用 Scoop 安装的所有软件都恢复了。 结尾 # 好了，小玲已经介绍了最基本的 Scoop 的使用方法了。只要你不是开发者，这些命令应该够你日常使用了。小玲自己平常使用的最多的也就是 scoop update -a 而已。如果你想知道 Scoop 还有哪些命令，可以通过 scoop help 查看。想知道如何制作一个 app 的元数据，可以查看 Scoop 的 Wiki 来源： Criteria for including apps in the main bucket 。 ↩︎ 阅读其它文章 ← 使用 Kotlin 语言实现一个快速排序算法 分享一个 TranslucentTB 的配置 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows/",
    "title": "Windows ::\n星野玲的博客",
    "text": "Windows ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows10/",
    "title": "Windows10 ::\n星野玲的博客",
    "text": "Windows10 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows11/",
    "title": "Windows11 ::\n星野玲的博客",
    "text": "Windows11 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/11/",
    "title": "Windows 包管理器——Scoop 上手教程 ::\n星野玲的博客",
    "text": "Windows 包管理器——Scoop 上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——Scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 安装 Scoop # 安装前请确保已经安装了 Powershell 5.1 或更新的版本。现在的 Windows 10 在安装完系统后都已经自带了上面这两个了。所以使用 Windows 10 的你一般情况下不用特地去再安装了。 第一次安装时，咱们先要指定 Scoop 的安装路径，因为这个路径还决定了使用 Scoop 安装的软件的安装路径，所以请务必考虑好安装在哪。小玲的建议是不要安装在 C 盘，这样如果你重装系统后，你使用 Scoop 安装的软件就不会被删除，可以很快地把软件恢复回来而不用再一个一个下载。下面的 Scoop 变量的值 D:\\Users\\DemoUser\\Scoop 和 SCOOP_GLOBAL 变量的值 D:\\Scoop 是小玲为了演示使用的路径。请根据你的实际情况修改为适合你的值。 SCOOP 变量的值是 Scoop 在当前用户安装的位置。 SCOOP_GLOBAL 变量的值是是 Scoop 在全局安装的位置。 [ Environment ]::SetEnvironmentVariable( 'SCOOP' , 'D:\\Users\\DemoUser\\Scoop' , 'User' ); [ Environment ]::SetEnvironmentVariable( 'SCOOP_GLOBAL' , 'D:\\Scoop' , 'Machine' ); Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser; irm get.scoop.sh | iex 启动 Powershell，把上面的命令一行行地复制进终端执行就可以安装 Scoop 了。注意 [Environment]::SetEnvironmentVariable('SCOOP_GLOBAL', 'D:\\Scoop', 'Machine'); 这条命令需要管理员权限。所以你需要打开有管理员权限的 Powershell 才能执行这条命令。 开始使用 # Git 是每个使用 Scoop 的人必须装的 app，有了 Git，咱们才能添加 bucket。所以安装完 Scoop 的第一件事就是安装 Git。 scoop install git Bucket # bucket 是一个 app 元数据的集合，一个 bucket 存放在 Git 仓库里。安装完 Scoop 后默认只有 main Bucket。 下面是 Scoop 社区维护的 bucket。 你可以通过 scoop bucket known 查看这个列表。 通过 scoop bucket list 查看已添加的 bucket。 通过 scoop bucket add <bucket> 添加 bucket。 通过 scoop bucket rm <bucket> 移除 bucket。 bucket 添加命令 移除命令 main scoop bucket add main scoop bucket rm main extras scoop bucket add extras scoop bucket rm extras versions scoop bucket add versions scoop bucket rm versions nirsoft scoop bucket add nirsoft scoop bucket rm nirsoft sysinternals scoop bucket add sysinternals scoop bucket rm sysinternals php scoop bucket add php scoop bucket rm php nerd-fonts scoop bucket add nerd-fonts scoop bucket rm nerd-fonts nonportable scoop bucket add nonportable scoop bucket rm nonportable java scoop bucket add java scoop bucket rm java games scoop bucket add games scoop bucket rm games Scoop 社区就规定 main bucket 存放着开发者会用到的 app，比如某种语言的开发环境。还有一些知名的 CLI 程序。它的最大特点就是没有 GUI。（当然 7zip 是个例外。） 1 Extras bucket 存放着不符合 main bucket 规定但又知名的程序。比如浏览器这种 GUI 程序，你都可以在 extras bucket 里找到。 Versions bucket 存放着一些知名的 app 的旧版本。 Php bucket 存放着从远古版本到最新版本的 PHP。 Nerd-fonts bucket 存放着 Nerd 字体和其他字体。 Nonportable 存放着非便携软件。也就是重装系统后虽然文件还在硬盘上，但已经不能正常运行的软件。比如通常的第三方输入法就是非便携软件。小玲不建议大家通过 Scoop 安装非便携软件。如果你的 Scoop 是安装在非 C 盘上的，重装系统后通过 Scoop 安装的非便携软件的文件虽然还残留在硬盘上，但已经不能正常使用了，这时你需要先通过 Scoop 卸载再安装才能使用。对于非便携软件，小玲建议通过 winget 安装。 Java bucket 存放着不同版本的 JRE 和 JDK。 Games bucket 存放着开源游戏和免费游戏。 一般来说 main 仓库和 extras 仓库是每个人必备的仓库。 注意事项 # 如果你在没装 Git 的情况下通过 scoop bucket rm main 把 main bucket 移除了。这时候你就会发现你因为没有 Git，无法通过 scoop bucket add main 添加 main bucket，而且因为没有 main bucket，无法通过 scoop install git 安装 Git。这时候貌似陷入了一个死循环。不过好在 Scoop 可以通过 scoop install <mainfest_url> 的方式安装一个 app 。所以咱们只需通过 scoop install https://raw.githubusercontent.com/ScoopInstaller/Main/master/bucket/git.json 就可以安装 Git 啦。 安装 app # 添加完 bucket 后就可以安装 app 了，咱们可以通过 scoop install 命令来安装 app，命令格式如下。 scoop install [<bucket_name>/]<app_name>[@<version>] scoop install <manifest_url> 例如，安装 Chrome。 scoop bucket add extras scoop install googlechrome 但是假如有两个 bucket 都有 googlechrome 这个 app。那通过 scoop install googlechrome 安装的是哪个 bucket 的 googlechrome 呢？ 咱们可以通过 scoop search 命令来搜索 app，遇到不同 bucket 里有同名的 app 时一般会安装搜索结果里最靠前的那个 bucket 的 app。 如果要指定安装某个 bucket 的 app 就需要这样子写。 scoop install extras/googlechrome 如果要安装指定版本的 app 就需要这样子写。 scoop install extras/googlechrome@107.0.5304.107 小玲也建议大家平常安装 app 时，先搜索一下 app 的名字，如果有两个或以上的 bucket 都有同名的 app 时，通过上面的方法精确定位你要安装的 app。 如果想为所有用户安装，就要使用 -g 参数来进行全局安装，卸载时也是如此。 搜索 app # scoop search <app_name> 不过 Scoop 自带的搜索命令在 bucket 数量多时会比较慢，小玲建议大家安装 scoop-search 这个包。 scoop install main/scoop-search 通过 scoop-search 命令来搜索会比 scoop search 快很多。 scoop-search <app_name> 卸载 app # scoop uninstall <app_name> 一些 app 会产生能被 Scoop 管理的数据，如果你想在卸载 app 时同时删除这些数据，请加入 -p 参数。 查看已安装的 APP # scoop list 更新 Scoop # scoop update 这个命令可以更新 Scoop 和 bucket 的元数据。 更新 app # scoop update <app_name> 如果要更新所有 app，可以使用 scoop update * 或 scoop update -a 。 禁止更新 app # 如果你希望一直使用某个 app 的旧版本，不希望在使用 scoop update -a 时将它升级到最新版，可以使用这个命令禁止更新这个 app。 scoop hold <app_name> 解除禁止更新可以用这个命令。 scoop unhold <app_name> 清理旧版本 # scoop cleanup <app_name> Scoop 在安装 app 的新版本时，不会删除旧版本。所以咱们需要用这个命令来清理旧版本。 清理安装文件 # Scoop 在安装 app 时，会保留安装文件。 你可以通过 scoop cache 查看所有安装文件。 通过 scoop cache rm <app_name> 删除指定 app 的安装文件。 通过 scoop cache rm * 或 scoop cache rm -a 或 scoop cache rm --all 删除所有安装文件。 设置 Scoop # 你可以通过 scoop help config 来查看 Scoop 都有哪些设置。 通过 scoop config 查看所有已修改的设置。 通过 scoop config <config_name> 查看设置的值。 通过 scoop config <config_name> <value> 更新设置。 通过 scoop config rm <config_name> 删除设置。 给 Scoop 设置代理 # 如果在使用 Scoop 时遇到下载慢的问题，可以给 Scoop 设置一个代理。这个代理得是 HTTP 代理，SOCKS 代理是不行的。 scoop config proxy [<username> : <password>@]host : port 使用 Aria2 多线程下载 # 你可以使用 Aria2 多线程下载。不过并不是什么 app 都支持多线程下载的。有时候会有下载失败的情况。小玲的建议是开启代理就行了，如果代理的速度够快，就没有必要使用多线程下载。 安装 Aria2。 scoop install main/aria2 让 Scoop 使用 aria2 scoop config aria2-enabled true 让 Scoop 不使用 aria2 scoop config aria2-enabled false 重装系统后恢复 Scoop # 重装系统后，只需重新设置一下环境变量，不需要重新下载 Scoop。注意下面的路径要设置成你原来的路径。 [ Environment ]::SetEnvironmentVariable( 'SCOOP' , 'D:\\Users\\DemoUser\\Scoop' , 'User' ) [ Environment ]::SetEnvironmentVariable( 'SCOOP_GLOBAL' , 'D:\\Scoop' , 'Machine' ) [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; \" + [ Environment ]::GetEnvironmentVariable( 'SCOOP' , 'User' ) + \"\\shims\" , 'User' ) # 注意下面的命令需要管理员权限。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'Machine' ) + \"; \" + [ Environment ]::GetEnvironmentVariable( 'SCOOP_GLOBAL' , 'Machine' ) + \"\\shims\" , 'Machine' ) Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 恢复所有 Scoop 安装的软件。 scoop reset * 然后你就会发现，原来使用 Scoop 安装的所有软件都恢复了。 结尾 # 好了，小玲已经介绍了最基本的 Scoop 的使用方法了。只要你不是开发者，这些命令应该够你日常使用了。小玲自己平常使用的最多的也就是 scoop update -a 而已。如果你想知道 Scoop 还有哪些命令，可以通过 scoop help 查看。想知道如何制作一个 app 的元数据，可以查看 Scoop 的 Wiki 来源： Criteria for including apps in the main bucket 。 ↩︎ 阅读其它文章 ← 使用 Kotlin 语言实现一个快速排序算法 分享一个 TranslucentTB 的配置 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/8/",
    "title": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客",
    "text": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知， TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 效果 # 桌面下，小玲设置了背景颜色为白色，并有一点点不透明。之所以不设置成全透明是因为全透明时，白色的字容易看不清。 桌面 任务视图下，小玲设置了背景颜色为黑色，并将透明度设置成与任务视图几乎一致。这样的效果就是，任务栏与任务视图融为一体，肉眼几乎看不出任务栏与任务视图的分界线。 任务视图 最大化窗口时，任务栏不再是一片纯色。而是壁纸里未被遮挡的部分。 最大化窗口时 设置方法 # 首先，请安装 Microsoft Store 里的 TranslucentTB，然后打开资源管理器，在地址栏中粘贴 %LOCALAPPDATA%\\Packages\\28017CharlesMilette.TranslucentTB_v826wp6bftszj\\RoamingState 后回车，编辑 settings.json 文件。用下面的内容覆盖原来的内容，保存就行了。 // See https://TranslucentTB.github.io/config for more information { \"$schema\" : \"https://sylveon.dev/TranslucentTB/schema\" , \"desktop_appearance\" : { \"accent\" : \"clear\" , \"color\" : \"#0000000A\" , \"show_peek\" : false }, \"visible_window_appearance\" : { \"enabled\" : false , \"accent\" : \"clear\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"maximized_window_appearance\" : { \"enabled\" : false , \"accent\" : \"blur\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"start_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"search_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"task_view_opened_appearance\" : { \"enabled\" : true , \"accent\" : \"clear\" , \"color\" : \"#00000066\" , \"show_peek\" : false }, \"battery_saver_appearance\" : { \"enabled\" : false , \"accent\" : \"opaque\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"ignored_windows\" : { \"window_class\" : [], \"window_title\" : [], \"process_name\" : [] }, \"hide_tray\" : false , \"disable_saving\" : false , \"verbosity\" : \"warn\" } 阅读其它文章 ← Windows 包管理器——Scoop 上手教程 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/translucenttb/",
    "title": "TranslucentTB ::\n星野玲的博客",
    "text": "TranslucentTB ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows/",
    "title": "Windows ::\n星野玲的博客",
    "text": "Windows ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 阅读更多 → Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/windows10/",
    "title": "Windows10 ::\n星野玲的博客",
    "text": "Windows10 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知，TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/8/",
    "title": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客",
    "text": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知， TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 效果 # 桌面下，小玲设置了背景颜色为白色，并有一点点不透明。之所以不设置成全透明是因为全透明时，白色的字容易看不清。 桌面 任务视图下，小玲设置了背景颜色为黑色，并将透明度设置成与任务视图几乎一致。这样的效果就是，任务栏与任务视图融为一体，肉眼几乎看不出任务栏与任务视图的分界线。 任务视图 最大化窗口时，任务栏不再是一片纯色。而是壁纸里未被遮挡的部分。 最大化窗口时 设置方法 # 首先，请安装 Microsoft Store 里的 TranslucentTB，然后打开资源管理器，在地址栏中粘贴 %LOCALAPPDATA%\\Packages\\28017CharlesMilette.TranslucentTB_v826wp6bftszj\\RoamingState 后回车，编辑 settings.json 文件。用下面的内容覆盖原来的内容，保存就行了。 // See https://TranslucentTB.github.io/config for more information { \"$schema\" : \"https://sylveon.dev/TranslucentTB/schema\" , \"desktop_appearance\" : { \"accent\" : \"clear\" , \"color\" : \"#0000000A\" , \"show_peek\" : false }, \"visible_window_appearance\" : { \"enabled\" : false , \"accent\" : \"clear\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"maximized_window_appearance\" : { \"enabled\" : false , \"accent\" : \"blur\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"start_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"search_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"task_view_opened_appearance\" : { \"enabled\" : true , \"accent\" : \"clear\" , \"color\" : \"#00000066\" , \"show_peek\" : false }, \"battery_saver_appearance\" : { \"enabled\" : false , \"accent\" : \"opaque\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"ignored_windows\" : { \"window_class\" : [], \"window_title\" : [], \"process_name\" : [] }, \"hide_tray\" : false , \"disable_saving\" : false , \"verbosity\" : \"warn\" } 阅读其它文章 ← Windows 包管理器——Scoop 上手教程 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/page/2/",
    "title": "星野玲的博客",
    "text": "星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 使用 Debian 作为路由器 2022-02-19 — 作者： 星野玲 #Armbian #Debian #Nanopi R4S #路由器 #软路由 在这篇文章里，小玲将教你如何将一个装着干净的 Debian 系统的设备变成一个能让局域网内设备上网的软路由。 阅读更多 → Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 阅读更多 → ← 较新的文章 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/20/",
    "title": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客",
    "text": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲以前没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 fnm 是使用 Rust 编写的，意味着咱们可以在 Linux、macOS、Windows 上都能使用 fnm。这里小玲就拿 Windows 作为例子。 安装 # 使用 Scoop 安装 fnm 。 scoop install main/fnm 安装好后，需要往 $profile 文件加一行命令使得 fnm 在 PowerShell 中生效，小玲就用 VSCode 编辑 $profile 了。如果没有安装 VSCode，可以通过 scoop install extras/vscode 安装。 code $profile 在最后一行添加下面的命令。 fnm env --use-on-cd | Out-String | Invoke-Expression 设置镜像 # fnm 默认是从 Node.js 官网下载的，有时候下载会特别慢。咱们可以使用下面的命令设置环境变量，将源设置成国内阿里云的。 [ Environment ]::SetEnvironmentVariable( 'FNM_NODE_DIST_MIRROR' , 'https://mirrors.aliyun.com/nodejs-release/' , 'User' ); 使用上面的命令设置了环境变量之后，请重启终端使环境变量生效。 版本号 # 在 fnm 里，Node.js 的版本号是可以省略小版本号的，省略了小版本号之后，剩下大版本号是指这个大版本下的最新一个小版本。 例如最新的 Node.js 版本是 20.8.1 ， 20.8 就等同于 20.8.1 而不是 20.8.0 。 20 就等同于 20.8 而不是 20.7 、 20.6 以及更低的版本。 安装最新的 Node.js # fnm install --latest 安装任意一个版本的 Node.js # fnm install <version> 例如 fnm install 20 卸载任意一个版本的 Node.js # fnm uninstall <version> 卸载时，如果执行 fnm uninstall 20 ，但是已经安装了两个或以上的 20 大版本的 Node.js，这时候就需要把版本号写更精确一些。 查看当前安装了哪些版本 # fnm ls 标有 default 的版本是当前正在使用的版本。 查看可以安装哪些版本 # fnm ls-remote 使用某个版本 # fnm use <version> 将当前使用的版本添加到 Path 环境变量 # 虽然咱们能在 PowerShell 使用 node 命令了，但是咱们并没有把 node 命令所在的文件夹加入 Path 环境变量，这样 WebStorm 就没有识别到使用 fnm 安装的 Node.js。 解决方法也很简单，使用下面的命令把路径添加到 Path 环境变量就可以了。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; $env:APPDATA \\fnm\\aliases\\default\" , 'User' ) 如果 WebStorm 里还是没有识别到，可以试试重启系统。 阅读其它文章 使用 NetworkManager 配置 Debian 路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/18/",
    "title": "关于 router.push() 会报错这件事 ::\n星野玲的博客",
    "text": "关于 router.push() 会报错这件事 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 这是一个 vue 文件，看似没有什么问题。 < template > <!-- 创建一个退出登录按钮 --> < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' // 定义一个名为logout的函数，用于处理退出登录的逻辑 function logout () { // 显示一个退出登录成功的消息提示框 ElMessage ({ message : '退出登录成功' , // 在消息提示框关闭时执行回调函数 onClose : async () => { // 获取Vue Router实例 const router = useRouter () // 执行路由跳转，跳转到名为'login'的路由 await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 不过，咱们把它运行起来，在点击退出登录按钮后，并没有成功跳转到名为 login 的路由，控制台报错： Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'push') 看样子， router 这个常量是 undefined 的。按理来说不应该呀，根据 文档 ，通过调用 useRouter() 函数应该会返回一个 Vue Router 实例。 小玲想了想，会不会是 const router = useRouter() 这个语句的位置不对，小玲把它放在这里的理由是 router 常量第一次使用的时候就是在这，想着挨近一点比较好。于是小玲移动 const router = useRouter() 到 onClose 外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' function logout () { const router = useRouter () ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 还是不行，那再移动到 lougot() 函数外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' const router = useRouter () function logout () { ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 这次就正常了，小玲后来搜了搜，原来已经 有人遇到过这个问题了 。总而言之， useRouter() 一定要在 script 标签里的顶层调用。 至于为什么， 文档 里有提到 useRouter() 是用来替代以前的写法中的 this.$router 。 因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route 。作为替代，我们使用 useRouter 和 useRoute 函数。 假设咱们还在使用以前的写法，如果不放在顶层，那么这个 this 指向谁呢？相信聪明的你一定能理解小玲的意思，小玲就不再赘述了。 阅读其它文章 ← 使用 NetworkManager 配置 Debian 路由器 Docker 下的 Traefik 上手教程（二） → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/5/",
    "title": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客",
    "text": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 小玲在网上搜索教程时发现，网上大部分教程都是在裸机内直接部署服务器。这样部署有一个缺点，就是步骤多，更新麻烦。正好小玲会 Docker，何不把它做成一个 Docker 镜像？部署的话直接启动容器就可以了，更新也是一个命令的事。于是小玲自己写了一个 Dockerfile 文件，并把它开源在 Github ，Docker Hub 也有已经构建好的 镜像 。 使用教程 # 要想使用小玲做的 Docker 镜像，你必须会使用 Linux、Docker 和 Docker Compose。教程这里采用的系统是 Debian 11，Docker 版本为 20.10.17，Dockers Compose 版本为 2.9.0。 安装 Docker # sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose # sudo wget \"https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose 国内服务器可能会无法下载 Github 的文件，咱们可以通过镜像站下载。 sudo wget \"https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 准备 server.cfg 文件 # server.cfg 是求生之路2服务器的配置文件，它的写法可以参考这个 教程 。小玲这里就给一个非常简单的配置。 mkdir ~/l4d2server vim ~/l4d2server/server.cfg // 服务器名 hostname \"Left 4 Dead 2 dedicated server\" // hidden 用于在服务器列表里隐藏你的服务器，防止被人发现并 DDOS sv_tags hidden 准备 host.txt 文件 # host.txt 文件是玩家进入服务器后，右上角显示的横幅的内容, 它的内容就在这里定义。你也可以留空，让它为一个空白的文本文件。 准备 motd.txt 文件 # MOTD 的全称为 Message of the Day，作用是玩家刚进入服务器时，会显示一个欢迎消息，可以为空。 touch ~/l4d2server/motd.txt 编写 docker-compose.yml 文件 # vim ~/l4d2server/docker-compose.yml version : \"3\" services : l4d2server : command : \"-secure +exec server.cfg +map c1m1_hotel -port 27015\" container_name : l4d2server image : hoshinorei/l4d2server:edge ports : - 27015 : 27015 - 27015 : 27015 /udp # 你也可以使用 host 的网络模式，减少 Docker 映射端口带来的性能损耗，不过这点损耗可以忽略不计。 # network_mode: host restart : unless-stopped stdin_open : true tty : true volumes : # 这里主机上的要映射到容器的路径请根据你的实际情况调整。 # 如果主机上没有 addons 这个文件夹，创建容器时会自动在主机上创建这个文件夹。 - ./addons/:/home/steam/l4d2server/left4dead2/addons/ - ./cfg/server.cfg:/home/steam/l4d2server/left4dead2/cfg/server.cfg:ro - ./host.txt:/home/steam/l4d2server/left4dead2/host.txt:ro - ./motd.txt:/home/steam/l4d2server/left4dead2/motd.txt:ro 最后一个命令创建并启动容器。 sudo docker-compose -f ~/l4d2server/docker-compose.yml -d 进入服务器的控制台 # 你可以通过以下命令进入服务器的控制台。 sudo docker attach l4d2server 这样，一个求生之路2的原版纯净服务器就安装好了，你也可以像其他教程一样安装 sourcemod 插件，这里就不赘述了。 阅读其它文章 ← 华硕AX86U 鬼灭之刃版伪开箱 使用 Debian 作为路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/dockercompose/",
    "title": "DockerCompose ::\n星野玲的博客",
    "text": "DockerCompose ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/left4dead2/",
    "title": "Left4Dead2 ::\n星野玲的博客",
    "text": "Left4Dead2 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/5/",
    "title": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客",
    "text": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 小玲在网上搜索教程时发现，网上大部分教程都是在裸机内直接部署服务器。这样部署有一个缺点，就是步骤多，更新麻烦。正好小玲会 Docker，何不把它做成一个 Docker 镜像？部署的话直接启动容器就可以了，更新也是一个命令的事。于是小玲自己写了一个 Dockerfile 文件，并把它开源在 Github ，Docker Hub 也有已经构建好的 镜像 。 使用教程 # 要想使用小玲做的 Docker 镜像，你必须会使用 Linux、Docker 和 Docker Compose。教程这里采用的系统是 Debian 11，Docker 版本为 20.10.17，Dockers Compose 版本为 2.9.0。 安装 Docker # sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose # sudo wget \"https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose 国内服务器可能会无法下载 Github 的文件，咱们可以通过镜像站下载。 sudo wget \"https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 准备 server.cfg 文件 # server.cfg 是求生之路2服务器的配置文件，它的写法可以参考这个 教程 。小玲这里就给一个非常简单的配置。 mkdir ~/l4d2server vim ~/l4d2server/server.cfg // 服务器名 hostname \"Left 4 Dead 2 dedicated server\" // hidden 用于在服务器列表里隐藏你的服务器，防止被人发现并 DDOS sv_tags hidden 准备 host.txt 文件 # host.txt 文件是玩家进入服务器后，右上角显示的横幅的内容, 它的内容就在这里定义。你也可以留空，让它为一个空白的文本文件。 准备 motd.txt 文件 # MOTD 的全称为 Message of the Day，作用是玩家刚进入服务器时，会显示一个欢迎消息，可以为空。 touch ~/l4d2server/motd.txt 编写 docker-compose.yml 文件 # vim ~/l4d2server/docker-compose.yml version : \"3\" services : l4d2server : command : \"-secure +exec server.cfg +map c1m1_hotel -port 27015\" container_name : l4d2server image : hoshinorei/l4d2server:edge ports : - 27015 : 27015 - 27015 : 27015 /udp # 你也可以使用 host 的网络模式，减少 Docker 映射端口带来的性能损耗，不过这点损耗可以忽略不计。 # network_mode: host restart : unless-stopped stdin_open : true tty : true volumes : # 这里主机上的要映射到容器的路径请根据你的实际情况调整。 # 如果主机上没有 addons 这个文件夹，创建容器时会自动在主机上创建这个文件夹。 - ./addons/:/home/steam/l4d2server/left4dead2/addons/ - ./cfg/server.cfg:/home/steam/l4d2server/left4dead2/cfg/server.cfg:ro - ./host.txt:/home/steam/l4d2server/left4dead2/host.txt:ro - ./motd.txt:/home/steam/l4d2server/left4dead2/motd.txt:ro 最后一个命令创建并启动容器。 sudo docker-compose -f ~/l4d2server/docker-compose.yml -d 进入服务器的控制台 # 你可以通过以下命令进入服务器的控制台。 sudo docker attach l4d2server 这样，一个求生之路2的原版纯净服务器就安装好了，你也可以像其他教程一样安装 sourcemod 插件，这里就不赘述了。 阅读其它文章 ← 华硕AX86U 鬼灭之刃版伪开箱 使用 Debian 作为路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E5%BC%80%E7%AE%B1/",
    "title": "开箱 ::\n星野玲的博客",
    "text": "开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/20/",
    "title": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客",
    "text": "使用 fnm 管理 Node.js 版本 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 fnm 管理 Node.js 版本 2023-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #fnm #NodeJS #Windows 一直以来，小玲都是用 Scoop 来安装 Node.js 的。以前小玲只用 main bucket 下的 nodejs 这个包。因为小玲以前没有使用旧版的 Node.js 的需求（虽然这个问题也能用 Scoop 的 version bucket 解决。），有魔法以后也不用担心下载国外的文件慢的问题，但是小玲决定改变这种安装方式。 fnm 是使用 Rust 编写的，意味着咱们可以在 Linux、macOS、Windows 上都能使用 fnm。这里小玲就拿 Windows 作为例子。 安装 # 使用 Scoop 安装 fnm 。 scoop install main/fnm 安装好后，需要往 $profile 文件加一行命令使得 fnm 在 PowerShell 中生效，小玲就用 VSCode 编辑 $profile 了。如果没有安装 VSCode，可以通过 scoop install extras/vscode 安装。 code $profile 在最后一行添加下面的命令。 fnm env --use-on-cd | Out-String | Invoke-Expression 设置镜像 # fnm 默认是从 Node.js 官网下载的，有时候下载会特别慢。咱们可以使用下面的命令设置环境变量，将源设置成国内阿里云的。 [ Environment ]::SetEnvironmentVariable( 'FNM_NODE_DIST_MIRROR' , 'https://mirrors.aliyun.com/nodejs-release/' , 'User' ); 使用上面的命令设置了环境变量之后，请重启终端使环境变量生效。 版本号 # 在 fnm 里，Node.js 的版本号是可以省略小版本号的，省略了小版本号之后，剩下大版本号是指这个大版本下的最新一个小版本。 例如最新的 Node.js 版本是 20.8.1 ， 20.8 就等同于 20.8.1 而不是 20.8.0 。 20 就等同于 20.8 而不是 20.7 、 20.6 以及更低的版本。 安装最新的 Node.js # fnm install --latest 安装任意一个版本的 Node.js # fnm install <version> 例如 fnm install 20 卸载任意一个版本的 Node.js # fnm uninstall <version> 卸载时，如果执行 fnm uninstall 20 ，但是已经安装了两个或以上的 20 大版本的 Node.js，这时候就需要把版本号写更精确一些。 查看当前安装了哪些版本 # fnm ls 标有 default 的版本是当前正在使用的版本。 查看可以安装哪些版本 # fnm ls-remote 使用某个版本 # fnm use <version> 将当前使用的版本添加到 Path 环境变量 # 虽然咱们能在 PowerShell 使用 node 命令了，但是咱们并没有把 node 命令所在的文件夹加入 Path 环境变量，这样 WebStorm 就没有识别到使用 fnm 安装的 Node.js。 解决方法也很简单，使用下面的命令把路径添加到 Path 环境变量就可以了。 [ Environment ]::SetEnvironmentVariable( 'Path' , [ Environment ]::GetEnvironmentVariable( 'Path' , 'User' ) + \"; $env:APPDATA \\fnm\\aliases\\default\" , 'User' ) 如果 WebStorm 里还是没有识别到，可以试试重启系统。 阅读其它文章 使用 NetworkManager 配置 Debian 路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/18/",
    "title": "关于 router.push() 会报错这件事 ::\n星野玲的博客",
    "text": "关于 router.push() 会报错这件事 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 关于 router.push() 会报错这件事 2023-09-24 — 作者： 星野玲 #Vue #Vue3 #Vue Router 好久没有更新文章了，今天小玲水一篇文章。说说自己在使用 Vue 的时候踩到的一个坑。 这是一个 vue 文件，看似没有什么问题。 < template > <!-- 创建一个退出登录按钮 --> < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' // 定义一个名为logout的函数，用于处理退出登录的逻辑 function logout () { // 显示一个退出登录成功的消息提示框 ElMessage ({ message : '退出登录成功' , // 在消息提示框关闭时执行回调函数 onClose : async () => { // 获取Vue Router实例 const router = useRouter () // 执行路由跳转，跳转到名为'login'的路由 await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 不过，咱们把它运行起来，在点击退出登录按钮后，并没有成功跳转到名为 login 的路由，控制台报错： Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'push') 看样子， router 这个常量是 undefined 的。按理来说不应该呀，根据 文档 ，通过调用 useRouter() 函数应该会返回一个 Vue Router 实例。 小玲想了想，会不会是 const router = useRouter() 这个语句的位置不对，小玲把它放在这里的理由是 router 常量第一次使用的时候就是在这，想着挨近一点比较好。于是小玲移动 const router = useRouter() 到 onClose 外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' function logout () { const router = useRouter () ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 还是不行，那再移动到 lougot() 函数外面。 < template > < el-button type = \"danger\" @ click = \"logout\" >退出登录</ el-button > </ template > < script setup lang = \"ts\" > import { ElButton , ElMessage } from 'element-plus' import { useRouter } from 'vue-router' const router = useRouter () function logout () { ElMessage ({ message : '退出登录成功' , onClose : async () => { await router . push ({ name : 'login' }) }, type : 'success' }) } </ script > 这次就正常了，小玲后来搜了搜，原来已经 有人遇到过这个问题了 。总而言之， useRouter() 一定要在 script 标签里的顶层调用。 至于为什么， 文档 里有提到 useRouter() 是用来替代以前的写法中的 this.$router 。 因为我们在 setup 里面没有访问 this，所以我们不能再直接访问 this.$router 或 this.$route 。作为替代，我们使用 useRouter 和 useRoute 函数。 假设咱们还在使用以前的写法，如果不放在顶层，那么这个 this 指向谁呢？相信聪明的你一定能理解小玲的意思，小玲就不再赘述了。 阅读其它文章 ← 使用 NetworkManager 配置 Debian 路由器 Docker 下的 Traefik 上手教程（二） → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/5/",
    "title": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客",
    "text": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 小玲在网上搜索教程时发现，网上大部分教程都是在裸机内直接部署服务器。这样部署有一个缺点，就是步骤多，更新麻烦。正好小玲会 Docker，何不把它做成一个 Docker 镜像？部署的话直接启动容器就可以了，更新也是一个命令的事。于是小玲自己写了一个 Dockerfile 文件，并把它开源在 Github ，Docker Hub 也有已经构建好的 镜像 。 使用教程 # 要想使用小玲做的 Docker 镜像，你必须会使用 Linux、Docker 和 Docker Compose。教程这里采用的系统是 Debian 11，Docker 版本为 20.10.17，Dockers Compose 版本为 2.9.0。 安装 Docker # sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose # sudo wget \"https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose 国内服务器可能会无法下载 Github 的文件，咱们可以通过镜像站下载。 sudo wget \"https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 准备 server.cfg 文件 # server.cfg 是求生之路2服务器的配置文件，它的写法可以参考这个 教程 。小玲这里就给一个非常简单的配置。 mkdir ~/l4d2server vim ~/l4d2server/server.cfg // 服务器名 hostname \"Left 4 Dead 2 dedicated server\" // hidden 用于在服务器列表里隐藏你的服务器，防止被人发现并 DDOS sv_tags hidden 准备 host.txt 文件 # host.txt 文件是玩家进入服务器后，右上角显示的横幅的内容, 它的内容就在这里定义。你也可以留空，让它为一个空白的文本文件。 准备 motd.txt 文件 # MOTD 的全称为 Message of the Day，作用是玩家刚进入服务器时，会显示一个欢迎消息，可以为空。 touch ~/l4d2server/motd.txt 编写 docker-compose.yml 文件 # vim ~/l4d2server/docker-compose.yml version : \"3\" services : l4d2server : command : \"-secure +exec server.cfg +map c1m1_hotel -port 27015\" container_name : l4d2server image : hoshinorei/l4d2server:edge ports : - 27015 : 27015 - 27015 : 27015 /udp # 你也可以使用 host 的网络模式，减少 Docker 映射端口带来的性能损耗，不过这点损耗可以忽略不计。 # network_mode: host restart : unless-stopped stdin_open : true tty : true volumes : # 这里主机上的要映射到容器的路径请根据你的实际情况调整。 # 如果主机上没有 addons 这个文件夹，创建容器时会自动在主机上创建这个文件夹。 - ./addons/:/home/steam/l4d2server/left4dead2/addons/ - ./cfg/server.cfg:/home/steam/l4d2server/left4dead2/cfg/server.cfg:ro - ./host.txt:/home/steam/l4d2server/left4dead2/host.txt:ro - ./motd.txt:/home/steam/l4d2server/left4dead2/motd.txt:ro 最后一个命令创建并启动容器。 sudo docker-compose -f ~/l4d2server/docker-compose.yml -d 进入服务器的控制台 # 你可以通过以下命令进入服务器的控制台。 sudo docker attach l4d2server 这样，一个求生之路2的原版纯净服务器就安装好了，你也可以像其他教程一样安装 sourcemod 插件，这里就不赘述了。 阅读其它文章 ← 华硕AX86U 鬼灭之刃版伪开箱 使用 Debian 作为路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker/",
    "title": "Docker ::\n星野玲的博客",
    "text": "Docker ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/dockercompose/",
    "title": "DockerCompose ::\n星野玲的博客",
    "text": "DockerCompose ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/left4dead2/",
    "title": "Left4Dead2 ::\n星野玲的博客",
    "text": "Left4Dead2 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E6%B1%82%E7%94%9F%E4%B9%8B%E8%B7%AF2/",
    "title": "求生之路2 ::\n星野玲的博客",
    "text": "求生之路2 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/5/",
    "title": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客",
    "text": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 小玲在网上搜索教程时发现，网上大部分教程都是在裸机内直接部署服务器。这样部署有一个缺点，就是步骤多，更新麻烦。正好小玲会 Docker，何不把它做成一个 Docker 镜像？部署的话直接启动容器就可以了，更新也是一个命令的事。于是小玲自己写了一个 Dockerfile 文件，并把它开源在 Github ，Docker Hub 也有已经构建好的 镜像 。 使用教程 # 要想使用小玲做的 Docker 镜像，你必须会使用 Linux、Docker 和 Docker Compose。教程这里采用的系统是 Debian 11，Docker 版本为 20.10.17，Dockers Compose 版本为 2.9.0。 安装 Docker # sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose # sudo wget \"https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose 国内服务器可能会无法下载 Github 的文件，咱们可以通过镜像站下载。 sudo wget \"https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 准备 server.cfg 文件 # server.cfg 是求生之路2服务器的配置文件，它的写法可以参考这个 教程 。小玲这里就给一个非常简单的配置。 mkdir ~/l4d2server vim ~/l4d2server/server.cfg // 服务器名 hostname \"Left 4 Dead 2 dedicated server\" // hidden 用于在服务器列表里隐藏你的服务器，防止被人发现并 DDOS sv_tags hidden 准备 host.txt 文件 # host.txt 文件是玩家进入服务器后，右上角显示的横幅的内容, 它的内容就在这里定义。你也可以留空，让它为一个空白的文本文件。 准备 motd.txt 文件 # MOTD 的全称为 Message of the Day，作用是玩家刚进入服务器时，会显示一个欢迎消息，可以为空。 touch ~/l4d2server/motd.txt 编写 docker-compose.yml 文件 # vim ~/l4d2server/docker-compose.yml version : \"3\" services : l4d2server : command : \"-secure +exec server.cfg +map c1m1_hotel -port 27015\" container_name : l4d2server image : hoshinorei/l4d2server:edge ports : - 27015 : 27015 - 27015 : 27015 /udp # 你也可以使用 host 的网络模式，减少 Docker 映射端口带来的性能损耗，不过这点损耗可以忽略不计。 # network_mode: host restart : unless-stopped stdin_open : true tty : true volumes : # 这里主机上的要映射到容器的路径请根据你的实际情况调整。 # 如果主机上没有 addons 这个文件夹，创建容器时会自动在主机上创建这个文件夹。 - ./addons/:/home/steam/l4d2server/left4dead2/addons/ - ./cfg/server.cfg:/home/steam/l4d2server/left4dead2/cfg/server.cfg:ro - ./host.txt:/home/steam/l4d2server/left4dead2/host.txt:ro - ./motd.txt:/home/steam/l4d2server/left4dead2/motd.txt:ro 最后一个命令创建并启动容器。 sudo docker-compose -f ~/l4d2server/docker-compose.yml -d 进入服务器的控制台 # 你可以通过以下命令进入服务器的控制台。 sudo docker attach l4d2server 这样，一个求生之路2的原版纯净服务器就安装好了，你也可以像其他教程一样安装 sourcemod 插件，这里就不赘述了。 阅读其它文章 ← 华硕AX86U 鬼灭之刃版伪开箱 使用 Debian 作为路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E5%BC%80%E7%AE%B1/",
    "title": "开箱 ::\n星野玲的博客",
    "text": "开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E5%BC%80%E7%AE%B1/",
    "title": "开箱 ::\n星野玲的博客",
    "text": "开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/6/",
    "title": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客",
    "text": "华硕AX86U 鬼灭之刃版伪开箱 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 华硕AX86U 鬼灭之刃版伪开箱 2022-08-08 — 作者： 星野玲 #华硕AX86U #开箱 #路由器 WiFi 6 路由器出来已经有 2 年了，但是小玲直到 2022 年 还没有用上 WiFi 6，所以小玲一直很想买个 WiFi 6 路由器。 小玲目前选路由器的标准有两个。 价格不能太贵。2000 以上的路由器小玲都没法买，因为小玲家里没矿。 这路由器呀，性能不能太烂。小玲家里没有埋网线，路由器都是放在客厅里的。虽说可以在地上拉一条网线到小玲的房间，但是这样子太丑。所以小玲希望在客厅和小玲的房间之间的网络用无线连接，而且速度是越快越好。几百块的便宜路由器可能速度会很慢。 小玲没买 AX86U 前看中了两款路由器，TP-Link TL-XTR10280 和华硕 RT-AX86U 鬼灭之刃版，小玲还看了好多这两款路由器的评测，小玲根据自己的需求，整理出了这两款路由器的对比。 对比项\\路由器 TP-Link TL-XTR10280 华硕 RT-AX86U 鬼灭之刃版 价格 较低 较高 性价比 较高 较低 无线性能 较高，毕竟是三频。如果未来再买一台 XTR10280，或许能实现小玲的房间和客厅之间拥有千兆的无线速度 较低，只有双频 可玩性 较低，因为 TP-Link 只给 16M 闪存，没法刷机，而且官方固件没有小玲想要的功能 较高，有梅林固件，几乎可以当作 Openwrt 来玩 外观 较差 较好，二次元皮肤加成，而且因为是立式的，占地面积还小 为什么小玲希望小玲的房间和客厅之间的速度越快越好呢？因为小玲有个 NAS 放在了客厅，小玲希望能高速地存取文件。拉网线的话虽然能达到千兆，但是明线的缺点小玲已经说过了。把 NAS 放在小玲的房间的话电源和噪音是个问题，所以只能寄希望于无线了。 经过激烈的思想斗争，小玲决定买了 AX86U。虽说华硕的产品都很贵，但是小玲相信华硕的产品应该不会差到哪里去，于是就有了这篇文章。 开箱 # 这是外包装的六个面。 外包装正面 外包装背面 外包装侧面 外包装侧面 外包装侧面 外包装侧面 拆开外包装后，是一个纯白的纸箱。 打开内包装。 先看看这些说明书。 App 设置指南 高级无线网络设置小帮手 快速使用指南 快速使用指南背面 保修卡 再来看看配件。 电源是 19.5V 2.31A，大约 45W 的电源。电源线是三孔的，过于普通就不展示了。 电源 还有三根天线和一个小鸟的小牌子。 天线和牌子 配件看完了，接下来是路由器本体。 路由器正面 路由器顶面 这一面有一个 WPS 按钮。 路由器侧面 这一面有一个 LED 灯光按钮，用于开关路由器正面的指示灯，小玲喜欢让这些灯开着。 路由器侧面 背面从左到右分别是电源输入口、开关、重置按钮、两个 USB 3.0 接口、一个 2.5G网口、一个千兆 WAN 口和四个千兆 LAN 口。其中 LAN1 口是游戏网口。 路由器背面 把天线装上。 装好天线后的路由器 配置 # 给路由器通上电、然后 WAN 口连接小玲的 R4S 后，电脑搜到了一个 ASUS 开头的 WiFi。 浏览器也自动打开了这个网页。 点击 创建新的网络 后。 填自己喜欢的 SSID 和密码。小玲这里就用原来的 SSID。 WiFi 6 是必须要开的。 设置路由器后台的用户名和密码。 还提示有新的固件，升就升吧。 经典的华硕固件登录页面。 登录后，也是经典的华硕路由器后台页面，只不过有了我妻善逸的画。左边还有一些 网易 UU 加速器 之类的功能。不过这些小玲都用不到，因为小玲是要把这款路由器当 AP 来用的。开了 AP 模式后，左边的很多功能都用不了了。 看一下系统信息，据说 AX86U 用的是和 AX89X 同款的四核 SoC，1 GB 内存。 有意思的是，当你用支持 WiFi 6 的网卡连接了 WiFi 6 的 WiFi 后，Windows 会有这样一个提示。 刷机并提高信号强度 # 用华硕路由器的人大概都知道把地区从 中国 更改为 澳大利亚 能提高信号强度吧？但其实还有个方法能把信号再提高一点，那就是刷 koolshare 的固件后装 wifi boost 插件。小玲已经刷好了 koolshare 的固件，刷的过程就不展示了。 wifi boost 插件是要收费的，价格是 30 元，一个激活码只能给一台路由器用。小玲也买了。 中国 地区的 WiFi 功率限制是 100mw。据说 澳大利亚 地区的功率能达到 300mw，利用 wifi boost ，小玲直接把功率拉到了 595.66mw。小玲不敢再往上拉了，如果烧坏了路由器就得不偿失了。 小玲的房间距离路由器直线大约有 7 米的距离，中间还隔了半堵墙和一扇木门。就算是这样，小玲在房间里用手机连接 5GHz 的 WiFi，手机显示的信号依然能满格，只不过连接速度没有满。 测速 # 小玲将电脑放在房间里，通过 AX200 网卡连接到客厅的路由器的 5GHz WiFi，并且在路由器里设置了一个周围都没人用的信道，通过 iPerf3 与 R4S 进行测速。测速时只有电脑一台设备连接了 5GHz WiFi，测速结果如下。 线程数\\方向 R4S -> 电脑 电脑 -> R4S 1 368 Mbits/s 408 Mbits/s 2 506 Mbits/s 531 Mbits/s 这个速度，小玲并不是很满意。虽然这个速度肯定是比小玲以前用 WiFi 5 高的，但还是离无线千兆比较远。 结尾 # 好了，这次开箱就到这里。其实 AX86U 小玲早就买了，也用了一段时间了，所以这不是第一次开箱，小玲姑且把它称作伪开箱吧。这篇文章小玲早就想写了，无奈太忙，终于今天把它写出来了。这也是小玲第一次做开箱，以后还会有更多的开箱的，那么咱们下篇文章见吧。 阅读其它文章 ← Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 使用 Docker 搭建求生之路2的服务器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/8/",
    "title": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客",
    "text": "分享一个 TranslucentTB 的配置 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 分享一个 TranslucentTB 的配置 2022-10-15 (最后修改于：\n2024-06-08) — 作者： 星野玲 #TranslucentTB #Windows #Windows10 众所周知， TranslucentTB 是 Windows 上最好用的能让任务栏透明的软件。但是怎么调教才能尽可能的漂亮呢？小玲自己调了下 TranslucentTB 的设置，总算调一个比较满意的设置。 效果 # 桌面下，小玲设置了背景颜色为白色，并有一点点不透明。之所以不设置成全透明是因为全透明时，白色的字容易看不清。 桌面 任务视图下，小玲设置了背景颜色为黑色，并将透明度设置成与任务视图几乎一致。这样的效果就是，任务栏与任务视图融为一体，肉眼几乎看不出任务栏与任务视图的分界线。 任务视图 最大化窗口时，任务栏不再是一片纯色。而是壁纸里未被遮挡的部分。 最大化窗口时 设置方法 # 首先，请安装 Microsoft Store 里的 TranslucentTB，然后打开资源管理器，在地址栏中粘贴 %LOCALAPPDATA%\\Packages\\28017CharlesMilette.TranslucentTB_v826wp6bftszj\\RoamingState 后回车，编辑 settings.json 文件。用下面的内容覆盖原来的内容，保存就行了。 // See https://TranslucentTB.github.io/config for more information { \"$schema\" : \"https://sylveon.dev/TranslucentTB/schema\" , \"desktop_appearance\" : { \"accent\" : \"clear\" , \"color\" : \"#0000000A\" , \"show_peek\" : false }, \"visible_window_appearance\" : { \"enabled\" : false , \"accent\" : \"clear\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"maximized_window_appearance\" : { \"enabled\" : false , \"accent\" : \"blur\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"start_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"search_opened_appearance\" : { \"enabled\" : false , \"accent\" : \"normal\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"task_view_opened_appearance\" : { \"enabled\" : true , \"accent\" : \"clear\" , \"color\" : \"#00000066\" , \"show_peek\" : false }, \"battery_saver_appearance\" : { \"enabled\" : false , \"accent\" : \"opaque\" , \"color\" : \"#00000000\" , \"show_peek\" : true }, \"ignored_windows\" : { \"window_class\" : [], \"window_title\" : [], \"process_name\" : [] }, \"hide_tray\" : false , \"disable_saving\" : false , \"verbosity\" : \"warn\" } 阅读其它文章 ← Windows 包管理器——Scoop 上手教程 Debian 软路由 + 华硕AX86U 实现多个 WiFi VLAN 隔离 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/5/",
    "title": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客",
    "text": "使用 Docker 搭建求生之路2的服务器 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 小玲在网上搜索教程时发现，网上大部分教程都是在裸机内直接部署服务器。这样部署有一个缺点，就是步骤多，更新麻烦。正好小玲会 Docker，何不把它做成一个 Docker 镜像？部署的话直接启动容器就可以了，更新也是一个命令的事。于是小玲自己写了一个 Dockerfile 文件，并把它开源在 Github ，Docker Hub 也有已经构建好的 镜像 。 使用教程 # 要想使用小玲做的 Docker 镜像，你必须会使用 Linux、Docker 和 Docker Compose。教程这里采用的系统是 Debian 11，Docker 版本为 20.10.17，Dockers Compose 版本为 2.9.0。 安装 Docker # sudo wget -qO- https://get.docker.com/ | sh 安装 Docker Compose # sudo wget \"https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose 国内服务器可能会无法下载 Github 的文件，咱们可以通过镜像站下载。 sudo wget \"https://ghproxy.com/https://github.com/docker/compose/releases/download/v2.9.0/docker-compose- $( uname -s ) - $( uname -m ) \" -O /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose 准备 server.cfg 文件 # server.cfg 是求生之路2服务器的配置文件，它的写法可以参考这个 教程 。小玲这里就给一个非常简单的配置。 mkdir ~/l4d2server vim ~/l4d2server/server.cfg // 服务器名 hostname \"Left 4 Dead 2 dedicated server\" // hidden 用于在服务器列表里隐藏你的服务器，防止被人发现并 DDOS sv_tags hidden 准备 host.txt 文件 # host.txt 文件是玩家进入服务器后，右上角显示的横幅的内容, 它的内容就在这里定义。你也可以留空，让它为一个空白的文本文件。 准备 motd.txt 文件 # MOTD 的全称为 Message of the Day，作用是玩家刚进入服务器时，会显示一个欢迎消息，可以为空。 touch ~/l4d2server/motd.txt 编写 docker-compose.yml 文件 # vim ~/l4d2server/docker-compose.yml version : \"3\" services : l4d2server : command : \"-secure +exec server.cfg +map c1m1_hotel -port 27015\" container_name : l4d2server image : hoshinorei/l4d2server:edge ports : - 27015 : 27015 - 27015 : 27015 /udp # 你也可以使用 host 的网络模式，减少 Docker 映射端口带来的性能损耗，不过这点损耗可以忽略不计。 # network_mode: host restart : unless-stopped stdin_open : true tty : true volumes : # 这里主机上的要映射到容器的路径请根据你的实际情况调整。 # 如果主机上没有 addons 这个文件夹，创建容器时会自动在主机上创建这个文件夹。 - ./addons/:/home/steam/l4d2server/left4dead2/addons/ - ./cfg/server.cfg:/home/steam/l4d2server/left4dead2/cfg/server.cfg:ro - ./host.txt:/home/steam/l4d2server/left4dead2/host.txt:ro - ./motd.txt:/home/steam/l4d2server/left4dead2/motd.txt:ro 最后一个命令创建并启动容器。 sudo docker-compose -f ~/l4d2server/docker-compose.yml -d 进入服务器的控制台 # 你可以通过以下命令进入服务器的控制台。 sudo docker attach l4d2server 这样，一个求生之路2的原版纯净服务器就安装好了，你也可以像其他教程一样安装 sourcemod 插件，这里就不赘述了。 阅读其它文章 ← 华硕AX86U 鬼灭之刃版伪开箱 使用 Debian 作为路由器 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/2/",
    "title": "Windows 上小狼毫输入法的上手教程 ::\n星野玲的博客",
    "text": "Windows 上小狼毫输入法的上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。现在小玲也来向大家传教。 安装 # 在 Windows 上，这款输入法有一个专属的名字——小狼毫（Weasel）。 小玲是直接采用 winget 安装的，当然你也可以在 Github 下载 这款输入法，小狼毫是开源的。 winget install --id=Rime.Weasel 设置用户文件夹 # 安装完成后，小玲强烈建议你把小狼毫的“用户资料夹”改成一个 C 盘以外的位置。这样重装系统后，只需把“用户资料夹”的位置设置为上一次设置的位置，输入法配置就全部回来啦。 你可以在开始菜单里的“【小狼毫】安装选项”设置位置。 删除原来的输入法 # 假设你原来原来的中文输入法只有微软拼音。这里以 Windows 10 为例，在你安装好后，系统设置里并没有添加小狼毫这个输入法，你需要在“设置”→“时间和语言”→“语言”→“首选语言”→“中文（简体，中国）”→“选项”→“键盘”里把小狼毫给添加进去，然后就可以把微软拼音删除啦。 设置输入方案 # 从现在开始咱们将通过编写配置文件的方式设置小狼毫。虽然小狼毫有一个“输入法设定”的功能。不过那个能设置的东西太少了，小玲也不会教你那么简单的东西。小玲将教你通过编写配置文件的方式设置小狼毫。不过在这之前，你需要熟悉 YAML 文件的语法。 首先，咱们需要打开小狼毫的“用户文件夹”然后在里面新建一个文件，命名为 default.custom.yaml ，然后写入以下内容。 patch : schema_list : - schema : luna_pinyin 切换系统输入法到小狼毫，右击任务栏里的“中”字图标，点击“重新部署”。咱们写的配置就生效啦。 这里的 schema 就是输入方案的意思。 luna_pinyin 是一个输入方案的 ID。你可以在小狼毫的“程序文件夹”里的 data 文件夹里找到输入法自带的所有输入方案，以 schema.yaml 为文件名的结尾的文件就是一个输入方案定义文件。咱们打开它，里面的 schema 对象下的 schema_id 对象的值就是它的 ID。 这些是小狼毫 0.14.3 自带的所有输入方案及其 ID。 方案ID 方案名称 luna_pinyin 朙月拼音 bopomofo 注音 bopomofo_express 注音-快打方式 bopomofo_tw 注音-台湾正体 cangjie5 仓颉五代 cangjie5_express 仓颉五代-快打模式 luna_pinyin_fluency 朙月拼音·语句流 luna_pinyin_simp 朙月拼音·简化字 luna_pinyin_tw 朙月拼音·台湾正体 luna_quanpin 全拼 stroke 五笔画 terra_pinyin 地球拼音 你可以把 luna_pinyin 替换成你想要的输入方案的 ID。如果你是全拼用户，那么使用“朙月拼音”就可以啦。如果你是双拼或五笔用户，你还需要下载输入方案，因为小狼毫并没有自带双拼和五笔的输入方案。 这里小玲以微软双拼和五笔为例，介绍小狼毫如何添加双拼和五笔输入方案。 咱们打开 双拼仓库 ，然后下载 double_pinyin_mspy.schema.yaml 文件，将它放到“用户文件夹”里，然后在 default.custom.yaml 里添加微软双拼的输入方案 ID。 patch : schema_list : - schema : luna_pinyin - schema : double_pinyin_mspy 如果你要使用五笔，你需要从 五笔仓库 下载 2 个文件，分别是 wubi86.dict.yaml 和 wubi86.schema.yaml ，将它们放到“用户文件夹”里，然后在 default.custom.yaml 里添加五笔的输入方案 ID。当然你也可以替换原来的输入方案 ID。 patch : schema_list : - schema : wubi86 最后请不要忘记“重新部署”小狼毫。 切换输入方案和简繁体 # 如果你在使用 2 个或以上的输入方案，你可以通过按 Ctrl + `键（` 就是数字键 1 左边的那个键），然后通过数字键或方向键来切换输入方案和简繁体。这个快捷键是可以改的。在 default.custom.yaml 文件的 patch 对象里增加 switcher 对象，然后在 switcher 对象里增加 hotkeys 对象。 hotkeys 对象的值是应该是一个数组，里面的一个元素对应一个快捷键，默认是 Control+grave （也就是 Ctrl + `）和 F4 ，小玲自己在用的是 Control+Shift+space ，也就是 Ctrl + Shift + 空格，小玲觉得默认的有点不太好按。你可以在 这里 找到更具体的设置介绍。 patch : switcher : hotkeys : # - Control+grave # - F4 - Control+Shift+space 设置皮肤 # 小狼毫默认自带的皮肤有 36 套，它们都在“程序文件夹”的 data 文件夹里的 weasel.yaml 文件里的 preset_color_schemes 对象里被定义。想要使用哪款皮肤，只需找到它的对象名就可以了。例如下面的 aqua 和 azure 就是一个皮肤的对象名。 preset_color_schemes : aqua : name : 碧水／Aqua author : 佛振 <chen.sst@gmail.com> text_color : 0x000000 back_color : 0xeceeee border_color : 0xe0e0e0 hilited_text_color : 0x000000 hilited_back_color : 0xd4d4d4 hilited_candidate_text_color : 0xffffff hilited_candidate_back_color : 0xfa3a0a azure : name : 青天／Azure author : 佛振 <chen.sst@gmail.com> text_color : 0xffe8ca candidate_text_color : 0xfff8ee back_color : 0x8b4e01 border_color : 0x8b4e01 hilited_text_color : 0xfff8ee hilited_back_color : 0x8b4e01 hilited_candidate_text_color : 0x7ffeff hilited_candidate_back_color : 0xa95e01 comment_text_color : 0xc69664 然后，咱们需要新建在“用户文件夹”里新建一个文件，命名为 weasel.custom.yaml ，然后写入以下内容。比如小玲现在想使用“青天／Azure”这个皮肤，小玲就把 patch 对象下的 style/color_scheme 对象的值设为 azure 。 patch : \"style/color_scheme\": azure 这里小玲使用的是上面这种写法，而不是使用下面这种写法。 patch : style : color_scheme : azure 因为下面这种写法——会使原本 style 里原本已经定义的其他对象变为未定义的。下面是“程序文件夹”的 data 文件夹里的 weasel.yaml 文件里的 style 对象。这些是小狼毫默认的样式设置。 style : color_scheme : aqua font_face : Microsoft YaHei font_point : 14 horizontal : false fullscreen : false inline_preedit : false preedit_type : composition display_tray_icon : false label_format : \"%s.\" layout : min_width : 160 min_height : 0 border_width : 3 margin_x : 12 margin_y : 12 spacing : 10 candidate_spacing : 5 hilite_spacing : 4 hilite_padding : 2 round_corner : 4 如果咱们使用下面这种写法，因为咱们写了 color_scheme 对象，它会覆盖输入法默认的 color_scheme 对象的值： aqua ，但是咱们并没有写 font_face 、 font_size 等对象，所以它们会变成未定义的，而不是会继承下来。如果写成上面这种写法，会被覆盖的对象就会只有 style 对象里的 color_scheme 对象。 style 对象里的其他对象将会被继承下来。 如果把 weasel.custom.yaml 写成这个样子，也是可以的。它会覆盖 style 对象里的所有对象。 patch : style : color_scheme : azure font_face : Microsoft YaHei font_point : 14 horizontal : false fullscreen : false inline_preedit : false preedit_type : composition display_tray_icon : false label_format : \"%s.\" layout : min_width : 160 min_height : 0 border_width : 3 margin_x : 12 margin_y : 12 spacing : 10 candidate_spacing : 5 hilite_spacing : 4 hilite_padding : 2 round_corner : 4 另外 style 对象里最值得一提的是 horizontal 对象，它控制着输入法的候选框是竖排的还是横排的。在 weasel.custom.yaml 文件里的 patch 对象里加入 style/horizontal 对象，并把它的值设为 true 。这样输入法的候选框就变成横排的啦。 patch : \"style/horizontal\": true 那么如何添加第三方皮肤呢？下面是小玲在网上找到的 2 款第三方皮肤的配置 1 。把它写进 weasel.custom.yaml 文件里的 patch 对象就可以啦。 patch : \"preset_color_schemes/placeless\" : author : \"jed <placeless@outlook.com>\" back_color : 0xFFFFFF candidate_text_color : 0x000000 hilited_candidate_back_color : 0xf57c75 hilited_candidate_text_color : 0xFFFFFF name : \"秋田／Placeless\" text_color : 0x000000 \"preset_color_schemes/placeless2\" : author : \"jed <placeless@outlook.com>\" back_color : 0xFFFFFF candidate_text_color : 0x666666 hilited_candidate_back_color : 0xFFFFFF hilited_candidate_text_color : 0xf57c75 name : \"荷田／Placeless\" text_color : 0x000000 可以看到这里定义皮肤时使用的写法是 patch : \"preset_color_schemes/placeless\" : # 省略 而不是 patch : preset_color_schemes : placeless\": # 省略 至于原因，小玲相信你也明白了。这是为了防止输入法自带的皮肤配置变成未定义的。 要使用这个第三方皮肤，只需把 weasel.custom.yaml 文件里的 patch 对象里的 style/color_scheme 对象的值设为 placeless 就可以啦。 patch : \"style/color_scheme\": placeless 设置快捷键 # 如果你用过微软拼音，你可能知道 Ctrl + 空格是切换中英文的快捷键。但是使用了小狼毫后再按 Ctrl + 空格会导致输入法被禁用。那么如何解决这个问题呢？ 你可以将下面的代码保存成一个 reg 文件，将它导入到你的注册表里 2 ，然后重启电脑。这样按 Ctrl + 空格就不会导致输入法被禁用啦。小玲实测 Windows 10 和 Windows 11 都可以使用这个方法。 Windows Registry Editor Version 5.00 [ HKEY_CURRENT_USER \\Control Panel\\Input Method\\Hot Keys\\00000010] \"Key Modifiers\" = hex: 00,c0,00,00 \"Virtual Key\" = hex: ff,00,00,00 [ HKEY_CURRENT_USER \\Control Panel\\Input Method\\Hot Keys\\00000070] \"Key Modifiers\" = hex: 00,c0,00,00 \"Virtual Key\" = hex: ff,00,00,00 现在按 Ctrl + 空格还不能切换中英文，咱们需要在 default.custom.yaml 文件里的 patch 对象里增加 key_binder 对象。具体配置如下。 patch : key_binder : bindings : - accept : Control+space toggle : ascii_mode when : always 经过添加上面的配置，现在咱们可以通过 Ctrl + 空格切换中英文啦。 小玲还自己设置了一些快捷键，比如下面这些。 patch : key_binder : bindings : - accept : Control+h send : Up when : composing - accept : Control+j send : Page_Down when : composing - accept : Control+k send : Page_Up when : composing - accept : Control+l send : Down when : composing 这 4 个快捷键的作用是在出现候选框时，可以通过按 Ctrl + H 和 Ctrl + L 移动选中的词，通过按 Ctrl + J 和 Ctrl + K 向下或向上翻页。如果把候选框变成横排的将会更直观。这可是微软拼音做不到的哦。因为小玲打字时是使用标准指法的（也就是左右手的食指分别放在 F 和 J 上）。以前用微软拼音时，要用左手手指伸很远去按数字键选词，现在只需通过左手小指按住左边的 Ctrl 键，然后右手几乎不用移动就可以选词，感觉方便多啦。 输入符号和短语 # 小狼毫默认的符号配置在“程序文件夹”的 data 文件夹里的 symbols.yaml 文件里。你可以打开这个文件查看你能输入哪些符号和短语。比如要输入一些特殊符号，就在中文输入模式下打 /fh ，候选框就会出现特殊符号了。 结尾 # 好了，通过上面的学习，相信你已经可以掌握小狼毫的基本使用方法了。如果还有什么不懂的，可以查看小狼毫的 官方文档 ，这篇文档比小玲写的要好多了。 这些配置来自 《 我的鼠须管配置 》，为了兼容小狼毫，小玲修改了一点点。 ↩︎ 方法参考 keyboard shortcuts - CTRL-Space always toggles Chinese IME (Windows 7) - Super User 。 ↩︎ 阅读其它文章 ← 使用 Debian 作为路由器 Windows 包管理器——winget 上手教程 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/docker/",
    "title": "Docker ::\n星野玲的博客",
    "text": "Docker ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Docker 下的 Traefik 上手教程（二） 2023-01-29 — 作者： 星野玲 #Docker #Docker Compose #Traefik 上周小玲讲了 Traefik 的基本使用方法。这周小玲来讲一些进阶的知识。 阅读更多 → Docker 下的 Traefik 上手教程 2023-01-22 — 作者： 星野玲 #Docker #Docker Compose #Traefik 今天小玲来给大家介绍小玲目前在服务器上用的负载均衡器——Traefik。 阅读更多 → 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/dockercompose/",
    "title": "DockerCompose ::\n星野玲的博客",
    "text": "DockerCompose ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/left4dead2/",
    "title": "Left4Dead2 ::\n星野玲的博客",
    "text": "Left4Dead2 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 使用 Docker 搭建求生之路2的服务器 2022-08-07 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Debian #Docker #DockerCompose #Left4Dead2 #求生之路2 求生之路（Left 4 Dead 2）是小玲平常玩的游戏之一，这款游戏虽然发售了 13 年，但至今依然有不小的热度。但是小玲在游玩时发现，官服哪怕是在香港的官服，延迟都挺大的，而且官服不支持第三方图，虽然游戏可以开本地服务器，但是经常会出现房主不卡，其他人都卡的情况。正好小玲有一个国内的服务器，所以小玲决定搭建一个求生之路的服务器，这样小玲和别人玩第三方图，大家的延迟都不会那么高。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/scoop/",
    "title": "Scoop ::\n星野玲的博客",
    "text": "Scoop ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/scoop/",
    "title": "Scoop ::\n星野玲的博客",
    "text": "Scoop ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——Scoop 上手教程 2023-01-01 (最后修改于：\n2024-06-08) — 作者： 星野玲 #Scoop #Windows #Windows10 #Windows11 今天小玲来介绍 Windows 上的又一个包管理器——scoop，这也是小玲在 Windows 系统上最喜欢也是用的最多的包管理器。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/rime/",
    "title": "Rime ::\n星野玲的博客",
    "text": "Rime ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/weasel/",
    "title": "Weasel ::\n星野玲的博客",
    "text": "Weasel ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/tags/%E5%B0%8F%E7%8B%BC%E6%AF%AB/",
    "title": "小狼毫 ::\n星野玲的博客",
    "text": "小狼毫 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 上小狼毫输入法的上手教程 2021-10-17 (最后修改于：\n2021-11-18) — 作者： 星野玲 #Rime #Windows #Weasel #小狼毫 小玲以前在使用 Windows 系统时，一直都是用系统自带的输入法——微软拼音的，而且小玲没有那种安装第三方输入法的习惯。但是有一天，小玲在网上看到好多人推荐的 Rime 输入法，抱着试一下的想法，小玲试用了一下这款输入法。没想到这款输入法的可定制性真的高。小玲从此就离不开这款输入法了。 阅读更多 → 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  },
  {
    "url": "https://blog.bling.moe/post/1/",
    "title": "Windows 包管理器——winget 上手教程 ::\n星野玲的博客",
    "text": "Windows 包管理器——winget 上手教程 ::\n星野玲的博客 星野玲的博客 RSS 关于 友链 查看更多 数字花园 RSS 关于 友链 数字花园 Windows 包管理器——winget 上手教程 2021-10-14 (最后修改于：\n2024-06-08) — 作者： 星野玲 #winget #Windows #Windows10 #Windows11 Windows程序包管理器（英语：Windows Package Manager，也称 winget）是微软为 Windows 10 开发的一款自由开源的软件包管理器。它由一个命令行实用程序（CLI）和一组安装应用程序的服务组成。独立软件供应商可以将其作为软件包的分发渠道。 1 为什么要使用 winget # 如果你是 Windows 使用者，你可能会经历过需要大量安装 win32 程序的痛苦：一个一个点开这些 exe 或 msi 文件，然后不断地点“下一步”，等待安装完成，再点“完成”。如果只是在一台电脑上安装还好，但是如果需要给 10 台，100 台电脑装软件，这个动作应该会让人抓狂吧？下载软件的时候也很麻烦，咱们需要去那个软件的官网，把它的安装包下载进来。如果不小心从某些乱七八糟的网站上下载，还有中毒的危险。如果你用过 Linux，你应该会体验过包管理器的便捷。想要什么软件，一个命令就把软件及其依赖给装好了。所以咱们需要一个 Windows 的包管理器，正好微软开发了 winget。咱们就来学习一下 winget 吧。 安装 # Windows 10 # 如果你用的是 Windows 10，请确保它的版本是 1809 及以上，不然是无法使用 winget 的。然后在应用商店里把“应用安装程序”更新到最新版，或者去 Github 下载 winget ，winget 的安装包是一个 msixbundle 文件，下载它并打开。完毕之后打开 PowerShell。输入 winget -v 并回车。如果终端返回一个版本号（比如 v1.1.12653 ）就表示安装成功啦。 如果你用的是 Windows 10 LTSC，由于 Windows 10 LTSC 不自带应用商店，无法按照上面的教程安装。你可以参考 这篇教程 。小玲亲测在 Windows 10 LTSC 2021 上安装成功。 Windows 11 # Windows 11 的安装步骤和 Windows 10 没有什么区别。 熟悉 winget # 咱们先来查看一个 winget 有哪些命令吧。输入 winget 并回车以查看 winget 的命令。你应该会看到下面的输出。 PS C:\\> winget Windows Package Manager v1.1.12653 版权所有 (C) Microsoft Corporation 。保留所有权利。 WinGet 命令行实用工具可从命令行安装应用程序和其他程序包。 使用情况: winget [< 命令 >] [< 选项 >] 下列命令有效: install 安装给定的程序包 show 显示包的相关信息 source 管理程序包的来源 search 查找并显示程序包的基本信息 list 显示已安装的程序包 upgrade 升级给定的程序包 uninstall 卸载给定的程序包 hash 哈希安装程序的帮助程序 validate 验证清单文件 settings 打开设置或设置管理员设置 features 显示实验性功能的状态 export 导出已安装程序包的列表 import 安装文件中的所有程序包 如需特定命令的更多详细信息，请向其传递帮助参数。 [-?] 下列选项可用： -v,--version 显示工具的版本 --info 显示工具的常规信息 可在此找到更多帮助： https : //aka.ms/winget-command-help PS C:\\Users\\Admin> 虽然 winget 有那么多命令，但咱们一般会用到的也就只有 6 个，分别是 命令 作用 winget install --id <id> 安装一个程序包 winget upgrade --id <id> 升级一个程序包 winget upgrade --all 升级所有程序包 winget uninstall --id <id> 卸载一个程序包 winget search <name> 搜索一个程序包 winget list 查看已安装的程序包 使用 winget 安装一个软件 # 如果想用 winget 安装一个软件，咱们需要知道它的 ID，因为软件的名字可以重复，但 ID 一定是唯一的。咱们需要先用 winget search 命令搜索咱们能在 winget 安装哪些软件。比如咱们需要安装一个 Chrome 浏览器。咱们就输入 winget search chrome 。 PS C:\\> winget search chrome 名称 ID 版本 匹配 源 ------------------------------------------------------------------------------------------ Streamer to Chromecast     9MTTSZ74DBRS               Unknown                      msstore Google Chrome              Google.Chrome 94.0 .4606.81 Moniker : chrome winget Google Chrome Beta         Google.Chrome.Beta 95.0 .4638.49 Command : chrome winget Google Chrome Dev          Google.Chrome.Dev 96.0 .4662.6  Command : chrome winget Stack                      stack.stack 3.32 .0       Tag : chrome     winget Brave                      BraveSoftware.BraveBrowser 95.1 .31.84   Tag : Chrome     winget Chrome Remote Desktop Host Google.ChromeRemoteDesktop 94.0 .4606.27 Tag : chrome     winget Ginger Chrome              Saxo_Broko.GingerChrome 93.0 .4529.0                  winget 115 电脑版 115 .115Chrome 25.0 .0.3                     winget 360 极速浏览器 360 .360Chrome 13.0 .2256.0                  winget Google Chrome Canary       Google.Chrome.Canary 97.0 .4668.0                  winget 终端返回了一个列表，里面正好有 Chrome 和它的 ID： Google.Chrome ，所以咱们就能通过 winget 安装 Chrome。咱们只需要输入 winget install --id Google.Chrome 。winget 就会帮咱们下载 Chrome 并安装。 PS C:\\> winget install --id Google.Chrome 已找到 Google Chrome [ Google.Chrome ] 版本 94.0 .4606.81 此应用程序由其所有者授权给你。 Microsoft 对第三方程序包概不负责，也不向第三方程序包授予任何许可证。 Downloading https : //dl.google.com/dl/chrome/install/googlechromestandaloneenterprise64.msi ██████████████████████████████ 78.2 MB / 78.2 MB 已成功验证安装程序哈希 正在启动程序包安装 ... 已成功安装 期间可能会弹出 UAC 的提示框，这时只需选“是”就可以了。如果你不想让安装的过程中弹出 UAC 提示框，还可以在有管理员权限的 PowerShell 窗口里执行命令。winget 默认会把软件安装在 C:\\Program Files 或 C:\\Program Files (x86) 等文件夹。 使用 winget 卸载一个软件 # 卸载一个程序包时咱们也需要知道它的 ID。如果你不记得它的 ID，可以使用 winget list 命令列出所有已安装的程序包的 ID。然后使用 winget uninstall --id <id> 命令卸载它。虽然有些不是通过 winget 安装的软件也会显示出来。小玲相信看到这里的你已经了解了 ID 的概念了，所以这部分小玲就不做演示了。 使用 winget 升级软件 # 咱们可以通过 winget upgrade --id <id> 单独升级一个程序包，使用 winget upgrade --all 命令升级 winget 能升级的程序包。 使用 winget 批量安装软件包 # winget 不支持一个命令安装多个程序包，比如 winget install --id=id1 --id=id2 是不行的。因此咱们需要写多个 winget install 命令，并用 ; 分开，咱们可以在文本编辑器里先写好命令，再复制到终端里执行。 比如下面的命令就可以一次性安装 Microsoft Virtual C++ 所有版本，注意最后一条命令后面不要写 ; 。 winget install --id=Microsoft.VC+ +2015 -2019Redist-x86; winget install --id=Microsoft.VC+ +2015 -2019Redist-x64; winget install --id=Microsoft.VC++2013Redist-x86; winget install --id=Microsoft.VC++2013Redist-x64; winget install --id=Microsoft.VC++2012Redist-x86; winget install --id=Microsoft.VC++2012Redist-x64; winget install --id=Microsoft.VC++2010Redist-x86; winget install --id=Microsoft.VC++2010Redist-x64; winget install --id=Microsoft.VC++2008Redist-x86; winget install --id=Microsoft.VC++2008Redist-x64; winget install --id=Microsoft.VC++2005Redist-x86; winget install --id=Microsoft.VC++2005Redist-x64 你可以仿照小玲写的例子，写一个适合你自己的命令。 注意事项 # 细心的你可能会注意到咱们通过 winget 安装 Chrome 时是从谷歌的服务器上下载的，因为 winget 没有设计一个服务器用于存放各个软件的安装包，所以你有可能会遇到一个软件的安装包下载不了。小玲相信你一定知道该怎么做了吧？小玲就不再赘述了。 结尾 # 最后小玲推荐给你一个网站—— winstall 。在这个网站你可以找到部分能通过 winget 安装的软件，而且网站会生成安装命令，你只需要复制进终端执行就可以安装啦。 选自 《 Windows程序包管理器 - 维基百科，自由的百科全书 》。 ↩︎ 阅读其它文章 ← Windows 上小狼毫输入法的上手教程 星野玲的博客 © 2024 Powered by Hugo Theme made by panr"
  }
]